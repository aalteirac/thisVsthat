/*global expect*/

var JSONPatch = require( "../src/index" );
var extend = require( "extend" );

describe( "JSON-Patch", function () {
	var patchee, patcheeClone;

	beforeEach( function () {
		patchee = {
			simpleString: "string",
			simpleNumber: 392,
			simpleBoolean: true,
			simpleArray: [392, "string", false],
			complexArray: [{
				qInfo: {
					qId: 1
				},
				simpleString: "string1"
			}, {
				qInfo: {
					qId: 2
				},
				simpleString: "string2"
			}, {
				qInfo: {
					qId: 3
				},
				simpleString: "string3"
			}],
			complexObject: {
				ctitle: "foo",
				array: [1, 2, 3],
				nestedObject: {
					foo: true,
					bar: true
				}
			},
			qvObjectArray: [{
				qInfo: {
					qId: 2
				},
				hello: "yes"
			}]
		};
		patcheeClone = extend( true, {}, patchee );
	} );

	describe( "Generating patches", function () {
		describe( "Simple patches", function () {
			it( "creates an 'add' patch", function () {
				patcheeClone.newProp = "hello";
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "add", path: "/newProp", value: "hello" } );
			} );

			it( "creates a 'replace' patch", function () {
				patcheeClone.simpleString = "hello";
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "replace", path: "/simpleString", value: "hello" } );
			} );

			it( "creates a 'replace' patch for simple arrays", function () {
				// since simple arrays has no way of identifying movement, we cannot
				// generate patches for specific items in those arrays
				var shouldEqual = [392, "string", false, "hello"];
				patcheeClone.simpleArray.push( "hello" );
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "replace", path: "/simpleArray", value: shouldEqual } );
			} );

			it( "creates a 'remove' patch", function () {
				delete patcheeClone.simpleString;
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "remove", path: "/simpleString" } );
			} );
		} );

		describe( "Complex array patches", function () {
			it( "creates an 'add' patch", function () {
				var shouldEqual = { qInfo: { qId: 4 } };
				patcheeClone.complexArray.push( shouldEqual );
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "add", path: "/complexArray/3", value: shouldEqual } );
			} );

			it( "creates a 'replace' patch", function () {
				var shouldEqual = { qInfo: { qId: 4 } };
				patcheeClone.complexArray[1] = shouldEqual;
				var patches = JSONPatch.generate( patchee, patcheeClone );
				// it's not explicitly a replace operation right now, but it creates a
				// 'remove' patch and an 'add' patch, which is what a 'replace' operation
				// basically does.
				//expect( patches.length ).to.equal( 1 );
				//expect( patches[0] ).to.deep.equal( { op: "replace", path: "/complexArray/1", value: shouldEqual } );
				expect( patches.length ).to.equal( 2 );
				expect( patches[0] ).to.deep.equal( { op: "remove", path: "/complexArray/1" } );
				expect( patches[1] ).to.deep.equal( { op: "add", path: "/complexArray/1", value: shouldEqual } );
			} );

			it( "creates a 'remove' patch", function () {
				patcheeClone.complexArray.splice( 1, 1 );
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 1 );
				expect( patches[0] ).to.deep.equal( { op: "remove", path: "/complexArray/1" } );
			} );
		} );

		describe( "Complex object patches", function () {
			it( "should generate replace and remove patches in the right order", function () {
				patcheeClone.complexObject.nestedObject.foo = false;
				delete patcheeClone.complexObject.nestedObject.bar;
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 2 );
				expect( patches[0] ).to.deep.equal( { op: "replace", path: "/complexObject/nestedObject/foo", value: false } );
				expect( patches[1] ).to.deep.equal( { op: "remove", path: "/complexObject/nestedObject/bar" } );
			} );

			it( "should track QlikView-tagged objects in arrays [qInfo->qId]", function () {
				var newObj = {
					qInfo: {
						qId: 3
					},
					bye: "yes"
				};
				patcheeClone.qvObjectArray.splice(0, 0, newObj );
				patcheeClone.qvObjectArray[1].hello = "no";
				var patches = JSONPatch.generate( patchee, patcheeClone );
				expect( patches.length ).to.equal( 2 );
				expect( patches[0] ).to.deep.equal( { op: "replace", path: "/qvObjectArray/0/hello", value: "no" } );
				expect( patches[1] ).to.deep.equal( { op: "add", path: "/qvObjectArray/0", value: newObj } );
			} );
		} );
	} );

	describe( "Applying patches", function () {
		describe( "Operation: 'add'", function () {
			it( "adds a simple property to an object", function () {
				var patches = [{ op: "add", path: "/prop", value: "hello" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.prop ).to.equal( "hello" );
			} );

			it( "adds a complex property to an object", function () {
				var patches = [{ op: "add", path: "/complexObject/foo", value: { bar: true } }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.complexObject.foo ).to.deep.equal( { bar: true } );
			} );

			it( "adds an item to the end of an array", function () {
				// index '-' is described in the IETF (JSONPointer) spec as the last index
				// (add new item to the end of the array)
				var patches = [{ op: "add", path: "/simpleArray/-", value: "last" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleArray.length ).to.equal( 4 );
				expect( patchee.simpleArray[3] ).to.equal( "last" );
			} );

			it( "adds an item in the middle of an array", function () {
				var patches = [{ op: "add", path: "/simpleArray/1", value: "middle" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleArray.length ).to.equal( 4 );
				expect( patchee.simpleArray[1] ).to.equal( "middle" );
			} );
		} );

		describe( "Operation: 'replace'", function () {
			it( "replaces a simple property", function () {
				var patches = [{ op: "replace", path: "/simpleString", value: "hello" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleString ).to.equal( "hello" );
			} );

			it( "replaces an object but keeping reference", function () {
				var oldProp = patchee.complexObject;
				var newProp = { anotherProp: true };
				var patches = [{ op: "replace", path: "/complexObject", value: newProp }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.complexObject ).to.deep.equal( newProp );
				expect( patchee.complexObject ).to.equal( oldProp );
			} );

			it( "replaces an array but keeping reference", function () {
				var oldProp = patchee.simpleArray;
				var newProp = [9, 8, 7];
				var patches = [{ op: "replace", path: "/simpleArray", value: newProp }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleArray ).to.deep.equal( newProp );
				expect( patchee.simpleArray ).to.equal( oldProp );
			} );

			it( "replaces a item inside an array", function () {
				var patches = [{ op: "replace", path: "/simpleArray/1", value: 5938 }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleArray.length ).to.equal( 3 );
				expect( patchee.simpleArray[1] ).to.equal( 5938 );
			} );
		} );

		describe( "Operation: 'remove'", function () {
			it( "removes a simple property", function () {
				var patches = [{ op: "remove", path: "/simpleString" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.hasOwnProperty( "simpleString" ) ).to.equal( false );
			} );

			it( "removes a nested property", function () {
				var patches = [{ op: "remove", path: "/complexObject/title" }];
				JSONPatch.apply( patchee, patches );
				expect( patchee.complexObject.hasOwnProperty( "title" ) ).to.equal( false );
			} );

			it( "removes a item in an array", function () {
				var patches = [{ op: "remove", path: "/simpleArray/1" }];
				var shouldEqual = [392, false];
				JSONPatch.apply( patchee, patches );
				expect( patchee.simpleArray ).to.deep.equal( shouldEqual );
			} );
		} );
	} );
} );
