{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///enigma.min.js","webpack:///webpack/bootstrap cbfdf76cef24c08d43ae","webpack:///./src/cache.js","webpack:///./src/event-emitter.js","webpack:///./~/extend/index.js","webpack:///./src/communication.js","webpack:///./src/services/qix/index.js","webpack:///./~/@qlik/json-patch/src/index.js","webpack:///./src/api-cache.js","webpack:///./src/index.js","webpack:///./src/rpc-resolver.js","webpack:///./src/rpc.js","webpack:///./src/services/qix/schema.js","webpack:///./src/services/qix/session.js","webpack:///./~/node-event-emitter/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","p","s","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","KeyValueCache","entries","entry","Error","_this","keys","map","_this2","filter","_interopRequireDefault","obj","__esModule","default","_nodeEventEmitter","_nodeEventEmitter2","mixin","forEach","init","hasOwn","hasOwnProperty","toStr","toString","isArray","arr","Array","isPlainObject","hasOwnConstructor","hasIsPrototypeOf","constructor","extend","options","name","src","copy","copyIsArray","clone","arguments","deep","_cache","_cache2","_extend","_extend2","assign","Communication","services","fn","add","_len","configs","_key","config","apply","undefined","concat","get","_session","_session2","_schema","_schema2","_rpc","_rpc2","_jsonPatch","_jsonPatch2","Qix","sessions","rpc","delta","schema","JSONPatch","Promise","notifications","url","createSocket","sessionConfig","appId","unsecure","host","port","prefix","subpath","route","identity","reloadURI","encodeURIComponent","buildUrl","session","disableCache","createRPC","createSession","on","remove","connect","then","args","handle","id","type","customType","globalApi","getObjectApi","openApp","openDoc","user","password","serial","noData","appSession","getSession","apiPromise","send","method","params","outKey","err","emit","getGlobal","g","app","global","mixins","registerMixin","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","generateValue","val","isSpecialProperty","isFunction","substring","getParent","data","str","numPart","seperator","parts","split","slice","part","isUndef","isNaN","emptyObject","getOwnPropertyDescriptor","compare","a","b","isIdentical","isObject","patchArray","original","newA","basePath","findIndex","idx","qInfo","qId","ii","ll","patches","oldA","tmpIdx","push","op","path","splice","generate","from","bind","v","newData","oldVal","tmpPath","patch","parent","newValues","oldParent","createPatch","toLowerCase","updateObject","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","_get","object","property","receiver","Function","desc","getPrototypeOf","getter","ApiCache","_KeyValueCache","api","deltaCache","patchee","set","_communication","_communication2","_index","_index2","communication","qix","registerService","_eventEmitter","_eventEmitter2","RPCResolver","resolve","reject","_rpcResolver","_rpcResolver2","RPC","resolvers","requestId","openPromise","socket","onopen","onOpen","onclose","onClose","onerror","onError","onmessage","onMessage","registerResolver","closePromise","open","resolveWith","event","close","rejectAllOutstandingResolvers","code","reason","rejectWith","JSON","parse","_this3","resolver","removeAllListeners","_this4","resolvedId","unregisterResolver","rejectedId","_this5","readyState","OPEN","jsonrpc","stringify","IGNORE_DELTA_METHODS","SUCCESS_KEY","Schema","json","def","types","_ref","override","cached","typeKey","entryList","structs","generateApi","typeDef","generateDefaultApi","mixinType","customKey","mixinList","fnName","Out","Name","allowDelta","indexOf","_ref2","_ref2$extend","_ref2$override","baseFn","_len2","_key2","_objectDestructuringEmpty","_typeof","Symbol","iterator","_apiCache","_apiCache2","RETURN_KEY","Session","definition","apis","responseInterceptors","onFulfilled","processErrorInterceptor","processDeltaInterceptor","processResultInterceptor","processOutInterceptor","processObjectApiInterceptor","evt","response","change","suspend","getApi","getApis","clear","meta","promise","intercept","addToPromiseChain","_args$delta","cacheId","isPrimitivePatch","setPatchee","getPatchee","applyPatch","interceptors","reduce","interception","interceptor","onRejected","error","result","cnt","qHandle","qType","qGenericId","qGenericType","chain","EventEmitter","util","arg","isNumber","isUndefined","_events","_maxListeners","defaultMaxListeners","setMaxListeners","n","er","handler","len","listeners","addListener","listener","newListener","warned","console","trace","once","removeListener","fired","list","position","ret","listenerCount","emitter"],"mappings":"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","file":"enigma.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"enigma\"] = factory();\n\telse\n\t\troot[\"enigma\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"enigma\"] = factory();\n\telse\n\t\troot[\"enigma\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Key value cache\n\t */\n\t\n\tvar KeyValueCache = function () {\n\t\tfunction KeyValueCache() {\n\t\t\t_classCallCheck(this, KeyValueCache);\n\t\n\t\t\tthis.entries = {};\n\t\t}\n\t\n\t\t/**\n\t  * @description Function used to add an entry.\n\t  * @param {String} key The key representing an entry.\n\t  * @param {*} entry The entry to be added.\n\t  */\n\t\n\t\n\t\t_createClass(KeyValueCache, [{\n\t\t\tkey: \"add\",\n\t\t\tvalue: function add(key, entry) {\n\t\t\t\tkey += \"\";\n\t\t\t\tif (typeof this.entries[key] !== \"undefined\") {\n\t\t\t\t\tthrow new Error(\"Entry already defined with key \" + key);\n\t\t\t\t}\n\t\t\t\tthis.entries[key] = entry;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to set an entry.\n\t   * @param {String} key The key representing an entry.\n\t   * @param {*} entry The entry.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"set\",\n\t\t\tvalue: function set(key, entry) {\n\t\t\t\tkey += \"\";\n\t\t\t\tthis.entries[key] = entry;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to remove an entry.\n\t   * @param {String} key The key representing an entry.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"remove\",\n\t\t\tvalue: function remove(key) {\n\t\t\t\tdelete this.entries[key];\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get an entry.\n\t   * @param {String} key The key representing an entry.\n\t   * @returns {*} The entry for the key.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"get\",\n\t\t\tvalue: function get(key) {\n\t\t\t\treturn this.entries[key];\n\t\t\t}\n\t\n\t\t\t/**\n\t  * @description Function used to get a list of all entries.\n\t  * @returns {Array} Returns the list of entries including its `key` and `value` properties.\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: \"getAll\",\n\t\t\tvalue: function getAll() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\treturn Object.keys(this.entries).map(function (key) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\tvalue: _this.entries[key]\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get a key for an entry.\n\t   * @param {*} entry The entry to locate the key for.\n\t   * @returns {String} The key representing an entry.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getKey\",\n\t\t\tvalue: function getKey(entry) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\treturn Object.keys(this.entries).filter(function (key) {\n\t\t\t\t\treturn _this2.entries[key] === entry;\n\t\t\t\t})[0];\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to clear the cache of all entries.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"clear\",\n\t\t\tvalue: function clear() {\n\t\t\t\tthis.entries = {};\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn KeyValueCache;\n\t}();\n\t\n\texports.default = KeyValueCache;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _nodeEventEmitter = __webpack_require__(12);\n\t\n\tvar _nodeEventEmitter2 = _interopRequireDefault(_nodeEventEmitter);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * @description Event emitter mixin.\n\t */\n\texports.default = {\n\t\n\t\t/**\n\t  * @description Function used to add event handling to objects passed in.\n\t  * @param {Object} obj Object instance that will get event handling.\n\t  */\n\t\n\t\tmixin: function mixin(obj) {\n\t\t\tObject.keys(_nodeEventEmitter2.default.prototype).forEach(function (key) {\n\t\t\t\tobj[key] = _nodeEventEmitter2.default.prototype[key];\n\t\t\t});\n\t\t\t_nodeEventEmitter2.default.init(obj);\n\t\t}\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _cache = __webpack_require__(0);\n\t\n\tvar _cache2 = _interopRequireDefault(_cache);\n\t\n\tvar _extend = __webpack_require__(2);\n\t\n\tvar _extend2 = _interopRequireDefault(_extend);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* istanbul ignore next */\n\tvar assign = Object.assign || _extend2.default; //N.B Don't use deep in extend\n\t\n\t/**\n\t * @description Entry point for communication definitions. You can add pre-defined service definitions that allows you to connect\n\t * and communicate with API endpoints.\n\t */\n\t\n\tvar Communication = function () {\n\t\t/**\n\t  * @description Creates a Communication object.\n\t  */\n\t\n\t\tfunction Communication() {\n\t\t\t_classCallCheck(this, Communication);\n\t\n\t\t\tthis.services = new _cache2.default();\n\t\t}\n\t\n\t\t/**\n\t  * @description Function used to register a communication service definition with a given key.\n\t  * @param {String} key Key to associate the defined service.\n\t  * @param {Function} fn Function that sets up and connects you to an endpoint.\n\t  */\n\t\n\t\n\t\t_createClass(Communication, [{\n\t\t\tkey: \"registerService\",\n\t\t\tvalue: function registerService(key, fn) {\n\t\t\t\tthis.services.add(key, fn);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get the API for a service endpoint.\n\t   * @param {String} key Key defining which communication definition to retrieve.\n\t   * @param {...Object} configs Object literal containing connect parameters for the requested endpoint. Look in each\n\t   * service definition for more info.\n\t   * @returns {Promise<Object>} Returns a promise containing an instance for the requested API if resolved, else an error is thrown.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getService\",\n\t\t\tvalue: function getService(key) {\n\t\t\t\tfor (var _len = arguments.length, configs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\tconfigs[_key - 1] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\tvar config = assign.apply(undefined, [{}].concat(configs));\n\t\t\t\tvar fn = this.services.get(key);\n\t\t\t\treturn fn(config);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Communication;\n\t}();\n\t\n\texports.default = Communication;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _session = __webpack_require__(11);\n\t\n\tvar _session2 = _interopRequireDefault(_session);\n\t\n\tvar _schema = __webpack_require__(10);\n\t\n\tvar _schema2 = _interopRequireDefault(_schema);\n\t\n\tvar _rpc = __webpack_require__(9);\n\t\n\tvar _rpc2 = _interopRequireDefault(_rpc);\n\t\n\tvar _cache = __webpack_require__(0);\n\t\n\tvar _cache2 = _interopRequireDefault(_cache);\n\t\n\tvar _jsonPatch = __webpack_require__(5);\n\t\n\tvar _jsonPatch2 = _interopRequireDefault(_jsonPatch);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Qix.\n\t */\n\t\n\tvar Qix = function () {\n\t\tfunction Qix() {\n\t\t\t_classCallCheck(this, Qix);\n\t\n\t\t\tthis.sessions = new _cache2.default();\n\t\t}\n\t\t/**\n\t  * @description Function used to create a session.\n\t  * @param {Object} rpc The RPC instance used by the session.\n\t  * @param {Boolean} delta=true Flag to determine delta handling.\n\t  * @param {Object} definition The Definition used by the session.\n\t  * @param {Object} JSONPatch JSON patch object.\n\t  * @param {Function} Promise The promise constructor.\n\t  * @returns {Object} Returns an instance of Session.\n\t  */\n\t\n\t\n\t\t_createClass(Qix, [{\n\t\t\tkey: \"createSession\",\n\t\t\tvalue: function createSession(rpc, delta, schema, JSONPatch, Promise, notifications) {\n\t\t\t\treturn new _session2.default(rpc, delta, schema, JSONPatch, Promise, notifications);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to create an RPC.\n\t   * @param {Function} Promise The promise constructor.\n\t   * @param {String} url The URL used to connect to an endpoint.\n\t   * @param {Function} createSocket The function callback to create a WebSocket.\n\t   * @param {Object} sessionConfig - The object to configure the session.\n\t   * @returns {Object} Returns an instance of RPC.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"createRPC\",\n\t\t\tvalue: function createRPC(Promise, url, createSocket, sessionConfig) {\n\t\t\t\treturn new _rpc2.default(Promise, url, createSocket, sessionConfig);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to build an URL.\n\t   * @param {Object} sessionConfig Configuration options for setting up the URL.\n\t   * @param {Boolean} [sessionConfig.unsecure=false] Set to true if a unsecure WebSocket should be used.\n\t   * @param {String} [sessionConfig.host] The hostname, for example \"localhost\" or \"foo.bar.com\". If omitted, localhost will used.\n\t   * @param {String|Number} [sessionConfig.port] The port.\n\t   * @param {String} [sessionConfig.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t   * @param {String} [sessionConfig.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t   * @param {String} [sessionConfig.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t   * @param {String} [sessionConfig.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t   * @param {String} [sessionConfig.reloadURI] The reloadURI.\n\t   * @param {String} [appId] The optional app id.\n\t   * @returns {String} Returns the URL.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"buildUrl\",\n\t\t\tvalue: function buildUrl(sessionConfig, appId) {\n\t\t\t\tvar unsecure = sessionConfig.unsecure;\n\t\t\t\tvar host = sessionConfig.host;\n\t\t\t\tvar port = sessionConfig.port;\n\t\t\t\tvar prefix = sessionConfig.prefix;\n\t\t\t\tvar subpath = sessionConfig.subpath;\n\t\t\t\tvar route = sessionConfig.route;\n\t\t\t\tvar identity = sessionConfig.identity;\n\t\t\t\tvar reloadURI = sessionConfig.reloadURI;\n\t\n\t\t\t\tvar url = \"\";\n\t\n\t\t\t\turl += unsecure ? \"ws\" : \"wss\";\n\t\t\t\turl += \"://\";\n\t\t\t\turl += host || \"localhost\";\n\t\n\t\t\t\tif (port) {\n\t\t\t\t\turl += \":\" + port;\n\t\t\t\t}\n\t\n\t\t\t\turl += prefix || \"/\";\n\t\n\t\t\t\tif (subpath) {\n\t\t\t\t\turl += subpath + \"/\";\n\t\t\t\t}\n\t\n\t\t\t\tif (route) {\n\t\t\t\t\turl += route;\n\t\t\t\t} else if (appId && appId !== \"\") {\n\t\t\t\t\turl += \"app/\" + encodeURIComponent(appId);\n\t\t\t\t}\n\t\n\t\t\t\tif (identity) {\n\t\t\t\t\turl += \"/identity/\" + encodeURIComponent(identity);\n\t\t\t\t}\n\t\n\t\t\t\turl += \"?reloadUri=\" + (reloadURI ? encodeURIComponent(reloadURI) : \"\");\n\t\n\t\t\t\treturn url;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get a session.\n\t   * @param {Object} config The object to configure the session.\n\t   * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t   * @param {Object} config.schema - The Schema definition used by the session.\n\t   * @param {Object} config.session The session configuration.\n\t   * @param {Function} config.Promise The promise constructor.\n\t   * @returns {Object} Returns a session instance.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getSession\",\n\t\t\tvalue: function getSession(config) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tvar url = this.buildUrl(config.session, config.appId);\n\t\t\t\tvar disableCache = config.session.disableCache;\n\t\n\t\n\t\t\t\tvar session = !disableCache && this.sessions.get(url);\n\t\t\t\tif (!session) {\n\t\t\t\t\tvar rpc = this.createRPC(config.Promise, url, config.createSocket, config.session);\n\t\t\t\t\tsession = this.createSession(rpc, config.delta, config.schema, config.JSONPatch, config.Promise, config.notifications);\n\t\t\t\t\tif (!disableCache) {\n\t\t\t\t\t\tthis.sessions.add(url, session);\n\t\t\t\t\t\tsession.on(\"close\", function () {\n\t\t\t\t\t\t\treturn _this.sessions.remove(url);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get the global API.\n\t   * @param {Object} session The session to get the global on.\n\t   * @param {Object} config The configuration object for how to connect and retrieve end QIX APIs.\n\t   * @param {Function} config.Promise The promise constructor.\n\t   * @param {Object} config.schema - The JSON object describing the api.\n\t   * @param {String} [config.appId] The app id. If omitted, only the global object is returned. Otherwise both global and app object are returned.\n\t   * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t   * @param {Object} [config.mixins=[]] An array of mixins.\n\t   * @param {Object} [config.session] The session configuration.\n\t   * @param {Boolean} [config.session.unsecure=false] Set to true if an unsecure WebSocket should be used.\n\t   * @param {String} [config.session.host] Host address.\n\t   * @param {Number} [config.session.port] Port to connect to.\n\t   * @param {String} [config.session.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t   * @param {String} [config.session.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t   * @param {String} [config.session.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t   * @param {String} [config.session.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t   * @param {String} [config.session.reloadURI] The reloadURI.\n\t   * @param {String} [config.session.disableCache=false] Set to true if you want a new Session.\n\t   * @returns {Promise<Object>} Returns a promise of an instance for the global API.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getGlobal\",\n\t\t\tvalue: function getGlobal(session, config) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\treturn session.connect().then(function () {\n\t\t\t\t\tvar args = { handle: -1, id: \"Global\", type: \"Global\", customType: \"Global\", delta: config.delta };\n\t\t\t\t\tvar globalApi = session.getObjectApi(args);\n\t\t\t\t\tglobalApi.openApp = globalApi.openDoc = function (appId) {\n\t\t\t\t\t\tvar user = arguments.length <= 1 || arguments[1] === undefined ? \"\" : arguments[1];\n\t\t\t\t\t\tvar password = arguments.length <= 2 || arguments[2] === undefined ? \"\" : arguments[2];\n\t\t\t\t\t\tvar serial = arguments.length <= 3 || arguments[3] === undefined ? \"\" : arguments[3];\n\t\t\t\t\t\tvar noData = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\t\n\t\t\t\t\t\tconfig.session.route = \"\";\n\t\t\t\t\t\tconfig.appId = appId;\n\t\n\t\t\t\t\t\tvar appSession = _this2.getSession(config);\n\t\n\t\t\t\t\t\tif (!appSession.apiPromise) {\n\t\t\t\t\t\t\tappSession.apiPromise = appSession.connect().then(function () {\n\t\t\t\t\t\t\t\treturn appSession.send({\n\t\t\t\t\t\t\t\t\tmethod: \"OpenDoc\",\n\t\t\t\t\t\t\t\t\thandle: -1,\n\t\t\t\t\t\t\t\t\tparams: [appId, user, password, serial, !!noData],\n\t\t\t\t\t\t\t\t\tdelta: false\n\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\tmethod: \"OpenDoc\",\n\t\t\t\t\t\t\t\t\thandle: -1,\n\t\t\t\t\t\t\t\t\toutKey: -1\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn appSession.apiPromise;\n\t\t\t\t\t};\n\t\t\t\t\treturn globalApi;\n\t\t\t\t}).catch(function (err) {\n\t\t\t\t\tsession.emit(\"close\", err);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get the global API and optionally the app.\n\t   * @param {Object} session The session to get the global on.\n\t   * @param {Object} config The object to configure.\n\t   * @returns {Promise} Returns a promise of a global API or an object containing the global API and the app API.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"get\",\n\t\t\tvalue: function get(session, config) {\n\t\t\t\treturn this.getGlobal(session, config).then(function (g) {\n\t\t\t\t\treturn config.appId ? g.openApp(config.appId, config.user, config.password, config.serial, config.noData).then(function (app) {\n\t\t\t\t\t\treturn { global: g, app: app };\n\t\t\t\t\t}) : g;\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to connect to QIX and return the global API and an optional app API.\n\t   * @param {Object} config The configuration object for how to connect and retrieve end QIX APIs.\n\t   * @param {Function} config.Promise The promise constructor.\n\t   * @param {Function} config.WebSocket The WebSocket constructor.\n\t   * @param {Object} config.schema - The JSON object describing the api.\n\t   * @param {String} [config.appId] The app id. If omitted, only the global object is returned. Otherwise both global and app object are returned.\n\t   * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t   * @param {Object} [config.mixins=[]] An array of mixins.\n\t   * @param {Object} [config.session] The session configuration.\n\t   * @param {Boolean} [config.session.unsecure=false] Set to true if an unsecure WebSocket should be used.\n\t   * @param {String} [config.session.host] Host address.\n\t   * @param {Number} [config.session.port] Port to connect to.\n\t   * @param {String} [config.session.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t   * @param {String} [config.session.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t   * @param {String} [config.session.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t   * @param {String} [config.session.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t   * @param {String} [config.session.reloadURI] The reloadURI.\n\t   * @param {String} [config.session.disableCache=false] Set to true if you want a new Session.\n\t   * @returns {Promise<Object>} Returns a promise containing an instance for the global API if resolved. If unresolved, an error will be thrown.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"connect\",\n\t\t\tvalue: function connect(config) {\n\t\t\t\tconfig.session = config.session || {};\n\t\t\t\tif (!(config.schema instanceof _schema2.default)) {\n\t\t\t\t\tconfig.schema = new _schema2.default(config.Promise, config.schema);\n\t\t\t\t}\n\t\t\t\tconfig.mixins = config.mixins || [];\n\t\t\t\tconfig.mixins.forEach(function (mixin) {\n\t\t\t\t\tconfig.schema.registerMixin(mixin);\n\t\t\t\t});\n\t\t\t\tconfig.JSONPatch = config.JSONPatch || _jsonPatch2.default;\n\t\n\t\t\t\tvar session = this.getSession(config);\n\t\t\t\treturn this.get(session, config);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Qix;\n\t}();\n\t\n\texports.default = Qix;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global module, define, require*/\n\t( function ( root, factory ) {\n\t\tif ( true ) {\n\t\t\t// amd:\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if ( typeof exports === \"object\" ) {\n\t\t\t// common.js:\n\t\t\tmodule.exports = factory( require( \"extend\" ) );\n\t\t} else {\n\t\t\t// browser (root = window):\n\t\t\troot.JSONPatch = factory( root.extend );\n\t\t}\n\t}( this, function ( extend ) {\n\t\textend = extend.bind( null, true );\n\t\n\t\tvar JSONPatch = {};\n\t\tvar isObject = function ( v ) { return v != null && !Array.isArray( v ) && typeof v === \"object\"; };\n\t\tvar isArray = Array.isArray;\n\t\tvar isUndef = function ( v ) { return typeof v === \"undefined\"; };\n\t\tvar isFunction = function ( v ) { return typeof v === \"function\"; };\n\t\n\t\t/**\n\t\t* Generate an exact duplicate (with no references) of a specific value.\n\t\t*\n\t\t* @private\n\t\t* @param {Object} The value to duplicate\n\t\t* @returns {Object} a unique, duplicated value\n\t\t*/\n\t\tfunction generateValue ( val ) {\n\t\t\tif ( val ) {\n\t\t\t\tval = extend( {}, { val: val } ).val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\n\t\t/**\n\t\t* An additional type checker used to determine if the property is of internal\n\t\t* use or not a type that can be translated into JSON (like functions).\n\t\t*\n\t\t* @private\n\t\t* @param {Object} obj The object which has the property to check\n\t\t* @param {String} The property name to check\n\t\t* @returns {Boolean} Whether the property is deemed special or not\n\t\t*/\n\t\tfunction isSpecialProperty( obj, key ) {\n\t\t\treturn isFunction( obj[key] ) ||\n\t\t\t\tkey.substring( 0, 2 ) === \"$$\" ||\n\t\t\t\tkey.substring( 0, 1 ) === \"_\";\n\t\t}\n\t\n\t\t/**\n\t\t* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n\t\t* also creates the object structure needed.\n\t\t*\n\t\t* @private\n\t\t* @param {Object} data The root object to traverse through\n\t\t* @param {String} The JSON-Pointer string to use when traversing\n\t\t* @returns {Object} The parent object\n\t\t*/\n\t\tfunction getParent( data, str ) {\n\t\t\tvar seperator = \"/\",\n\t\t\t\tparts = str.substring( 1 ).split( seperator ).slice( 0, -1 ),\n\t\t\t\tnumPart;\n\t\n\t\t\tparts.forEach( function ( part, i ) {\n\t\t\t\tif ( i === parts.length ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnumPart = +part;\n\t\t\t\tdata = data[numPart || part] = isUndef( data[numPart || part] ) ?\n\t\t\t\t\t!isNaN( numPart ) ?\n\t\t\t\t\t\t[] :\n\t\t\t\t\t\t{} :\n\t\t\t\t\tdata[part];\n\t\t\t} );\n\t\n\t\t\treturn data;\n\t\t}\n\t\n\t\t/**\n\t\t* Cleans an object of all its properties, unless they're deemed special or\n\t\t* cannot be removed by configuration.\n\t\t*\n\t\t* @private\n\t\t* @param {Object} obj The object to clean\n\t\t*/\n\t\tfunction emptyObject( obj ) {\n\t\t\tObject.keys( obj ).forEach( function ( key ) {\n\t\t\t\tvar config = Object.getOwnPropertyDescriptor( obj, key );\n\t\n\t\t\t\tif ( config.configurable && !isSpecialProperty( obj, key ) ) {\n\t\t\t\t\tdelete obj[key];\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\n\t\t/**\n\t\t* Compare an object with another, could be object, array, number, string, bool.\n\t\t*\n\t\t* @param {Object} a The first object to compare\n\t\t* @param {Object} a The second object to compare\n\t\t* @returns {Boolean} Whether the objects are identical\n\t\t*/\n\t\tfunction compare( a, b ) {\n\t\t\tvar isIdentical = true,\n\t\t\t\ti, l;\n\t\n\t\t\tif ( isObject( a ) && isObject( b ) ) {\n\t\t\t\tif ( Object.keys( a ).length !== Object.keys( b ).length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tObject.keys( a ).forEach( function ( key ) {\n\t\t\t\t\tif ( !compare( a[key], b[key] ) ) {\n\t\t\t\t\t\tisIdentical = false;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn isIdentical;\n\t\t\t} else if ( isArray( a ) && isArray( b ) ) {\n\t\t\t\tif ( a.length !== b.length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor ( i = 0, l = a.length; i < l; i++ ) {\n\t\t\t\t\tif ( !compare( a[i], b[i] ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn a === b;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t* Generates patches by comparing two arrays.\n\t\t*\n\t\t* @private\n\t\t* @param {Array} oldA The old (original) array, which will be patched\n\t\t* @param {Array} newA The new array, which will be used to compare against\n\t\t* @returns {Array} An array of patches (if any)\n\t\t*/\n\t\tfunction patchArray( original, newA, basePath ) {\n\t\t\tvar patches = [],\n\t\t\t\toldA = original.slice(),\n\t\t\t\ti, l, tmpIdx = -1;\n\t\n\t\t\tfunction findIndex( a, id, idx ) {\n\t\t\t\tif ( a[idx] && isUndef( a[idx].qInfo ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if ( a[idx] && a[idx].qInfo.qId === id ) {\n\t\t\t\t\t// shortcut if identical\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t\tfor ( var ii = 0, ll = a.length; ii < ll; ii++ ) {\n\t\t\t\t\tif ( a[ii] && a[ii].qInfo.qId === id ) {\n\t\t\t\t\t\treturn ii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\n\t\t\tif ( compare( newA, oldA ) ) {\n\t\t\t\t// array is unchanged\n\t\t\t\treturn patches;\n\t\t\t}\n\t\n\t\t\tif ( !isUndef( newA[0] ) && isUndef( newA[0].qInfo ) ) {\n\t\t\t\t// we cannot create patches without unique identifiers, replace array...\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: basePath,\n\t\t\t\t\tvalue: newA\n\t\t\t\t} );\n\t\t\t\treturn patches;\n\t\t\t}\n\t\n\t\t\tfor ( i = oldA.length - 1; i >= 0; --i ) {\n\t\t\t\ttmpIdx = findIndex( newA, oldA[i].qInfo && oldA[i].qInfo.qId, i );\n\t\t\t\tif ( tmpIdx === -1 ) {\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"remove\",\n\t\t\t\t\t\tpath: basePath + \"/\" + i\n\t\t\t\t\t} );\n\t\t\t\t\toldA.splice( i, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpatches = patches.concat( JSONPatch.generate( oldA[i], newA[tmpIdx], basePath + \"/\" + i ) );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = 0, l = newA.length; i < l; ++i ) {\n\t\t\t\ttmpIdx = findIndex( oldA, newA[i].qInfo && newA[i].qInfo.qId );\n\t\t\t\tif ( tmpIdx === -1 ) {\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"add\",\n\t\t\t\t\t\tpath: basePath + \"/\" + i,\n\t\t\t\t\t\tvalue: newA[i]\n\t\t\t\t\t} );\n\t\t\t\t\toldA.splice( i, 0, newA[i] );\n\t\t\t\t} else if ( tmpIdx !== i ) {\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"move\",\n\t\t\t\t\t\tpath: basePath + \"/\" + i,\n\t\t\t\t\t\tfrom: basePath + \"/\" + tmpIdx\n\t\t\t\t\t} );\n\t\t\t\t\toldA.splice( i, 0, oldA.splice( tmpIdx, 1 )[0] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn patches;\n\t\t}\n\t\n\t\t/**\n\t\t* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n\t\t*\n\t\t* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n\t\t*\n\t\t* Does NOT currently generate patches for arrays (will replace them)\n\t\t*\n\t\t* @param {Object} original The object to patch to\n\t\t* @param {Object} newData The object to patch from\n\t\t* @param {String} [basePath] The base path to use when generating the paths for the patches (normally not used)\n\t\t* @returns {Array} An array of patches\n\t\t*/\n\t\tJSONPatch.generate = function ( original, newData, basePath ) {\n\t\t\tbasePath = basePath || \"\";\n\t\t\tvar patches = [];\n\t\n\t\t\tObject.keys( newData ).forEach( function ( key ) {\n\t\t\t\tvar val = generateValue( newData[key] ),\n\t\t\t\t\toldVal = original[key],\n\t\t\t\t\ttmpPath = basePath + \"/\" + key;\n\t\n\t\t\t\tif ( compare( val, oldVal ) || isSpecialProperty( newData, key ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( isUndef( oldVal ) ) {\n\t\t\t\t\t// property does not previously exist\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"add\",\n\t\t\t\t\t\tpath: tmpPath,\n\t\t\t\t\t\tvalue: val\n\t\t\t\t\t} );\n\t\t\t\t} else if ( isObject( val ) && isObject( oldVal ) ) {\n\t\t\t\t\t// we need to generate sub-patches for this, since it already exist\n\t\t\t\t\tpatches = patches.concat( JSONPatch.generate( oldVal, val, tmpPath ) );\n\t\t\t\t} else if ( isArray( val ) && isArray( oldVal ) ) {\n\t\t\t\t\tpatches = patches.concat( patchArray( oldVal, val, tmpPath ) );\n\t\t\t\t} else {\n\t\t\t\t\t// it's a simple property (bool, string, number)\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"replace\",\n\t\t\t\t\t\tpath: basePath + \"/\" + key,\n\t\t\t\t\t\tvalue: val\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tObject.keys( original ).forEach( function ( key ) {\n\t\t\t\tif ( isUndef( newData[key] ) && !isSpecialProperty( original, key ) ) {\n\t\t\t\t\t// this property does not exist anymore\n\t\t\t\t\tpatches.push( {\n\t\t\t\t\t\top: \"remove\",\n\t\t\t\t\t\tpath: basePath + \"/\" + key\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\treturn patches;\n\t\t};\n\t\n\t\t/**\n\t\t* Apply a list of patches to an object.\n\t\t*\n\t\t* @param {Object} original The object to patch\n\t\t* @param {Array} patches The list of patches to apply\n\t\t*/\n\t\tJSONPatch.apply = function ( original, patches ) {\n\t\t\tpatches.forEach( function ( patch ) {\n\t\t\t\tvar parent = getParent( original, patch.path ),\n\t\t\t\t\tkey = patch.path.split( \"/\" ).splice( -1 )[0],\n\t\t\t\t\ttarget = key && isNaN( +key ) ? parent[key] : parent[+key] || parent,\n\t\t\t\t\tfrom = patch.from ? patch.from.split( \"/\" ).splice( -1 )[0] : null;\n\t\n\t\t\t\tif ( patch.path === \"/\" ) {\n\t\t\t\t\tparent = null;\n\t\t\t\t\ttarget = original;\n\t\t\t\t}\n\t\n\t\t\t\tif ( patch.op === \"add\" || patch.op === \"replace\" ) {\n\t\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\t\t// trust indexes from patches, so don't replace the index if it's an add\n\t\t\t\t\t\tif ( key === \"-\" ) {\n\t\t\t\t\t\t\tkey = parent.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparent.splice( +key, patch.op === \"add\" ? 0 : 1, patch.value );\n\t\t\t\t\t} else if ( isArray( target ) && isArray( patch.value ) ) {\n\t\t\t\t\t\tvar newValues = patch.value.slice();\n\t\t\t\t\t\t// keep array reference if possible...\n\t\t\t\t\t\ttarget.length = 0;\n\t\t\t\t\t\ttarget.push.apply( target, newValues );\n\t\t\t\t\t} else if ( isObject( target ) && isObject( patch.value ) ) {\n\t\t\t\t\t\t// keep object reference if possible...\n\t\t\t\t\t\temptyObject( target );\n\t\t\t\t\t\textend( target, patch.value );\n\t\t\t\t\t} else if ( !parent ) {\n\t\t\t\t\t\tthrow new Error( \"Patchee is not an object we can patch\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// simple value\n\t\t\t\t\t\tparent[key] = patch.value;\n\t\t\t\t\t}\n\t\t\t\t} else if ( patch.op === \"move\" ) {\n\t\t\t\t\tvar oldParent = getParent( original, patch.from );\n\t\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\t\tparent.splice( +key, 0, oldParent.splice( +from, 1 )[0] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent[key] = oldParent[from];\n\t\t\t\t\t\tdelete oldParent[from];\n\t\t\t\t\t}\n\t\t\t\t} else if ( patch.op === \"remove\" ) {\n\t\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\t\tparent.splice( +key, 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete parent[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t\n\t\t/**\n\t\t* Deep clone an object.\n\t\t*\n\t\t* @param {Object} obj The object to clone\n\t\t* @returns {Object} A new object identical to the `obj`\n\t\t*/\n\t\tJSONPatch.clone = function ( obj ) {\n\t\t\treturn extend( {}, obj );\n\t\t};\n\t\n\t\t/**\n\t\t* Creates a JSON-patch.\n\t\t*\n\t\t* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n\t\t* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val` is the \"from JSON-path\" path\n\t\t* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n\t\t* @returns {Object} A patch following the JSON-patch specification\n\t\t*/\n\t\tJSONPatch.createPatch = function ( op, val, path ) {\n\t\t\tvar patch = {\n\t\t\t\top: op.toLowerCase(),\n\t\t\t\tpath: path\n\t\t\t};\n\t\t\tif ( patch.op === \"move\" ) {\n\t\t\t\tpatch.from = val;\n\t\t\t} else if ( typeof val !== \"undefined\" ) {\n\t\t\t\tpatch.value = val;\n\t\t\t}\n\t\t\treturn patch;\n\t\t};\n\t\n\t\t/**\n\t\t* Apply the differences of two objects (keeping references if possible).\n\t\t* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n\t\t*\n\t\t* @param {Object} original The object to update/patch\n\t\t* @param {Object} newData the object to diff against\n\t\t*\n\t\t* @example\n\t\t* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n\t\t* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n\t\t* JSONPatch.updateObject(obj1, obj2);\n\t\t* // => { foo: [4,5,6], bar: { baz: false } };\n\t\t*/\n\t\tJSONPatch.updateObject = function ( original, newData ) {\n\t\t\tif ( !Object.keys( original ).length ) {\n\t\t\t\textend( original, newData );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tJSONPatch.apply( original, JSONPatch.generate( original, newData ) );\n\t\t};\n\t\n\t\treturn JSONPatch;\n\t} ) );\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _cache = __webpack_require__(0);\n\t\n\tvar _cache2 = _interopRequireDefault(_cache);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Api cache.\n\t */\n\t\n\tvar ApiCache = function (_KeyValueCache) {\n\t\t_inherits(ApiCache, _KeyValueCache);\n\t\n\t\tfunction ApiCache() {\n\t\t\t_classCallCheck(this, ApiCache);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(ApiCache).call(this));\n\t\t}\n\t\n\t\t/**\n\t  * Adds an api.\n\t  * @param {Number} handle - The handle for the api.\n\t  * @param {*} api - The api.\n\t  * @returns {{api: *, deltaCache}} The entry.\n\t  */\n\t\n\t\n\t\t_createClass(ApiCache, [{\n\t\t\tkey: \"add\",\n\t\t\tvalue: function add(handle, api) {\n\t\t\t\tvar entry = {\n\t\t\t\t\tapi: api,\n\t\t\t\t\tdeltaCache: new _cache2.default()\n\t\t\t\t};\n\t\t\t\t_get(Object.getPrototypeOf(ApiCache.prototype), \"add\", this).call(this, handle.toString(), entry);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Gets an api.\n\t   * @param {Number} handle - The handle for the api.\n\t   * @returns {*} The api for the handle.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getApi\",\n\t\t\tvalue: function getApi(handle) {\n\t\t\t\tvar entry = this.get(handle.toString());\n\t\t\t\treturn entry && entry.api;\n\t\t\t}\n\t\n\t\t\t/**\n\t  * Gets a list of apis.\n\t  * @returns {Array} The list of entries with `handle` and `api` properties for each entry.\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: \"getApis\",\n\t\t\tvalue: function getApis() {\n\t\t\t\treturn _get(Object.getPrototypeOf(ApiCache.prototype), \"getAll\", this).call(this).map(function (entry) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\thandle: entry.key,\n\t\t\t\t\t\tapi: entry.value.api\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Gets a patchee.\n\t   * @param {Number} handle - The handle for the api.\n\t   * @param {String} method - The method.\n\t   * @returns {*} The patchee.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getPatchee\",\n\t\t\tvalue: function getPatchee(handle, method) {\n\t\t\t\tvar entry = this.get(handle.toString());\n\t\t\t\treturn entry && entry.deltaCache.get(method);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Adds a patchee\n\t   * @param {Number} handle - The handle for the api.\n\t   * @param {String} method - The method.\n\t   * @param {Object} patchee - The patchee to add.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"addPatchee\",\n\t\t\tvalue: function addPatchee(handle, method, patchee) {\n\t\t\t\tthis.get(handle.toString()).deltaCache.add(method, patchee);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Sets a patchee\n\t   * @param {Number} handle - The handle for the api.\n\t   * @param {String} method - The method.\n\t   * @param {Object} patchee - The patchee to add.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"setPatchee\",\n\t\t\tvalue: function setPatchee(handle, method, patchee) {\n\t\t\t\tthis.get(handle.toString()).deltaCache.set(method, patchee);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn ApiCache;\n\t}(_cache2.default);\n\t\n\texports.default = ApiCache;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _communication = __webpack_require__(3);\n\t\n\tvar _communication2 = _interopRequireDefault(_communication);\n\t\n\tvar _index = __webpack_require__(4);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * @description EnigmaJS Communication module.\n\t * Add end point definitions to this object to retrieve sessions or HTTP REST communication API objects.\n\t * The communication module comes with a pre-defined Qlik Sense Qix Engine definition.\n\t */\n\t\n\t\n\tvar communication = new _communication2.default();\n\tvar qix = new _index2.default();\n\tcommunication.registerService(\"qix\", qix.connect.bind(qix));\n\t\n\texports.default = communication;\n\t\n\tmodule.exports = communication;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _eventEmitter = __webpack_require__(1);\n\t\n\tvar _eventEmitter2 = _interopRequireDefault(_eventEmitter);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar RPCResolver = function () {\n\t\tfunction RPCResolver(id, resolve, reject) {\n\t\t\t_classCallCheck(this, RPCResolver);\n\t\n\t\t\t_eventEmitter2.default.mixin(this);\n\t\t\tthis.id = id;\n\t\t\tthis.resolve = resolve;\n\t\t\tthis.reject = reject;\n\t\t}\n\t\n\t\t_createClass(RPCResolver, [{\n\t\t\tkey: \"resolveWith\",\n\t\t\tvalue: function resolveWith(data) {\n\t\t\t\tthis.resolve(data);\n\t\t\t\tthis.emit(\"resolved\", this.id);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"rejectWith\",\n\t\t\tvalue: function rejectWith(err) {\n\t\t\t\tthis.reject(err);\n\t\t\t\tthis.emit(\"rejected\", this.id);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn RPCResolver;\n\t}();\n\t\n\texports.default = RPCResolver;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _eventEmitter = __webpack_require__(1);\n\t\n\tvar _eventEmitter2 = _interopRequireDefault(_eventEmitter);\n\t\n\tvar _rpcResolver = __webpack_require__(8);\n\t\n\tvar _rpcResolver2 = _interopRequireDefault(_rpcResolver);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * RPC - Handle remote procedure calls\n\t */\n\t\n\tvar RPC = function () {\n\t\t/**\n\t  * @description Constructor\n\t  * @param {Function} Promise - The promise constructor.\n\t  * @param {String} url - The URL used to connect to an endpoint.\n\t  * @param {Function} createSocket The function callback to create a WebSocket.\n\t  * @param {Object} sessionConfig - The object to configure the session.\n\t  */\n\t\n\t\tfunction RPC(Promise, url, createSocket, sessionConfig) {\n\t\t\t_classCallCheck(this, RPC);\n\t\n\t\t\t_eventEmitter2.default.mixin(this);\n\t\t\tthis.Promise = Promise;\n\t\t\tthis.url = url;\n\t\t\tthis.createSocket = createSocket;\n\t\t\tthis.sessionConfig = sessionConfig;\n\t\t\tthis.resolvers = {};\n\t\t\tthis.requestId = 0;\n\t\t\tthis.openPromise = undefined;\n\t\t}\n\t\n\t\t/**\n\t  * @description Function used to open a connection to the configured endpoint.\n\t  * @returns {Object} Returns a promise instance.\n\t  */\n\t\n\t\n\t\t_createClass(RPC, [{\n\t\t\tkey: \"open\",\n\t\t\tvalue: function open() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tif (this.openPromise) {\n\t\t\t\t\treturn this.openPromise;\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tthis.socket = this.createSocket(this.url, this.sessionConfig);\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn this.Promise.reject(err);\n\t\t\t\t}\n\t\n\t\t\t\tthis.socket.onopen = this.onOpen.bind(this);\n\t\t\t\tthis.socket.onclose = this.onClose.bind(this);\n\t\t\t\tthis.socket.onerror = this.onError.bind(this);\n\t\t\t\tthis.socket.onmessage = this.onMessage.bind(this);\n\t\t\t\tthis.openPromise = new this.Promise(function (resolve, reject) {\n\t\t\t\t\treturn _this.registerResolver(\"open\", resolve, reject);\n\t\t\t\t});\n\t\t\t\tthis.closePromise = new this.Promise(function (resolve, reject) {\n\t\t\t\t\treturn _this.registerResolver(\"close\", resolve, reject);\n\t\t\t\t});\n\t\t\t\treturn this.openPromise;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to resolve the open promise when a connection is successfully established.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"onOpen\",\n\t\t\tvalue: function onOpen() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tthis.resolvers.open.resolveWith(function () {\n\t\t\t\t\treturn _this2.closePromise;\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to resolve the close promise when a connection is closed.\n\t   * @param {Object} event - The event describing close.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"onClose\",\n\t\t\tvalue: function onClose(event) {\n\t\t\t\tthis.emit(\"close\", event);\n\t\t\t\tthis.resolvers.close.resolveWith(event);\n\t\t\t\tthis.rejectAllOutstandingResolvers();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to close a connection.\n\t   * @param {Number} [code=1000] - The reason code for closing the connection.\n\t   * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n\t   * @returns {Object} Returns a promise instance.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"close\",\n\t\t\tvalue: function close() {\n\t\t\t\tvar code = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\t\t\t\tvar reason = arguments.length <= 1 || arguments[1] === undefined ? \"\" : arguments[1];\n\t\n\t\t\t\tthis.socket.close(code, reason);\n\t\t\t\treturn this.closePromise;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Emits an error event and rejects the open promise if an error is raised on the connection.\n\t   * @param {Object} event - The event describing the error.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"onError\",\n\t\t\tvalue: function onError(event) {\n\t\t\t\tif (this.resolvers.open) {\n\t\t\t\t\tthis.resolvers.open.rejectWith(event);\n\t\t\t\t} else {\n\t\t\t\t\t// only emit errors after the initial open promise has been resolved,\n\t\t\t\t\t// this makes it possible to catch early websocket errors as well\n\t\t\t\t\t// as run-time ones:\n\t\t\t\t\tthis.emit(\"error-socket\", event);\n\t\t\t\t}\n\t\t\t\tthis.rejectAllOutstandingResolvers();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to parse the onMessage event on the connection and resolve the promise for the request.\n\t   * @param {Object} event - The event describing the message.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"onMessage\",\n\t\t\tvalue: function onMessage(event) {\n\t\t\t\tvar data = JSON.parse(event.data);\n\t\t\t\tif (typeof data.id !== \"undefined\") {\n\t\t\t\t\tthis.emit(\"message\", data);\n\t\t\t\t\tthis.resolvers[data.id].resolveWith(data);\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit(data.params ? \"notification\" : \"message\", data);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to reject all outstanding resolvers.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"rejectAllOutstandingResolvers\",\n\t\t\tvalue: function rejectAllOutstandingResolvers() {\n\t\t\t\tvar _this3 = this;\n\t\n\t\t\t\tObject.keys(this.resolvers).forEach(function (id) {\n\t\t\t\t\tif (id === \"open\" || id === \"close\") {\n\t\t\t\t\t\treturn; //\"open\" and \"close\" should not be handled here\n\t\t\t\t\t}\n\t\t\t\t\tvar resolver = _this3.resolvers[id];\n\t\t\t\t\tresolver.rejectWith();\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to unregister a resolver.\n\t   * @param {Number|String} id - The ID to unregister the resolver with.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"unregisterResolver\",\n\t\t\tvalue: function unregisterResolver(id) {\n\t\t\t\tvar resolver = this.resolvers[id];\n\t\t\t\tresolver.removeAllListeners();\n\t\t\t\tdelete this.resolvers[id];\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to register a resolver.\n\t   * @param {Number|String} id - The ID to register the resolver with.\n\t   * @returns {Function} Returns the promise executor function.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"registerResolver\",\n\t\t\tvalue: function registerResolver(id, resolve, reject) {\n\t\t\t\tvar _this4 = this;\n\t\n\t\t\t\tvar resolver = this.resolvers[id] = new _rpcResolver2.default(id, resolve, reject);\n\t\t\t\tresolver.on(\"resolved\", function (resolvedId) {\n\t\t\t\t\treturn _this4.unregisterResolver(resolvedId);\n\t\t\t\t});\n\t\t\t\tresolver.on(\"rejected\", function (rejectedId) {\n\t\t\t\t\treturn _this4.unregisterResolver(rejectedId);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to send data on the socket.\n\t   * @param {Object} data - The data to send.\n\t   * @returns {Object} Returns a promise instance.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"send\",\n\t\t\tvalue: function send(data) {\n\t\t\t\tvar _this5 = this;\n\t\n\t\t\t\tif (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n\t\t\t\t\treturn this.Promise.reject(new Error(\"Not connected\"));\n\t\t\t\t}\n\t\t\t\tdata.jsonrpc = \"2.0\";\n\t\t\t\tdata.id = ++this.requestId;\n\t\t\t\tthis.socket.send(JSON.stringify(data));\n\t\t\t\treturn new this.Promise(function (resolve, reject) {\n\t\t\t\t\treturn _this5.registerResolver(data.id, resolve, reject);\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn RPC;\n\t}();\n\t\n\texports.default = RPC;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _cache = __webpack_require__(0);\n\t\n\tvar _cache2 = _interopRequireDefault(_cache);\n\t\n\tvar _eventEmitter = __webpack_require__(1);\n\t\n\tvar _eventEmitter2 = _interopRequireDefault(_eventEmitter);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar IGNORE_DELTA_METHODS = [\"GetProperties\", \"SetProperties\", \"GetFullPropertyTree\", \"SetFullPropertyTree\", \"GetAppProperties\", \"SetAppProperties\"];\n\t\n\tvar SUCCESS_KEY = \"qSuccess\";\n\t\n\t/**\n\t * Definitions\n\t */\n\t\n\tvar Schema = function () {\n\t\n\t\t/**\n\t  * @description Constructor.\n\t  * @param {Function} Promise The constructor function for a promise.\n\t  * @param {Object} json The JSON object that describes the API.\n\t  */\n\t\n\t\tfunction Schema(Promise, json) {\n\t\t\t_classCallCheck(this, Schema);\n\t\n\t\t\tthis.Promise = Promise;\n\t\t\tthis.mixins = new _cache2.default();\n\t\t\tthis.def = json;\n\t\t\tthis.types = new _cache2.default();\n\t\t}\n\t\n\t\t/**\n\t  * @description Function used to add a mixin object to the mixin cache. Will be mixed into the API\n\t  * of the specified key when generated.\n\t  * @param {Object} mixin Mixin object.\n\t  * @param {String|Array<String>} mixin.types String or array of strings containing the API-types that will be mixed in.\n\t  * @param {Object} [mixin.extend] Object literal containing the methods that will be extended on the specified API.\n\t  * @param {Object} [mixin.override] Object literal containing the methods to override existing methods.\n\t  * @param {Function} [mixin.init] Init function that, if defined, will run when an API is instantiated. It runs with Promise and API object as parameters.\n\t  */\n\t\n\t\n\t\t_createClass(Schema, [{\n\t\t\tkey: \"registerMixin\",\n\t\t\tvalue: function registerMixin(_ref) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tvar types = _ref.types;\n\t\t\t\tvar type = _ref.type;\n\t\t\t\tvar extend = _ref.extend;\n\t\t\t\tvar override = _ref.override;\n\t\t\t\tvar init = _ref.init;\n\t\n\t\t\t\tif (!Array.isArray(types)) {\n\t\t\t\t\ttypes = [types];\n\t\t\t\t}\n\t\t\t\t// to support a single type\n\t\t\t\tif (type) {\n\t\t\t\t\ttypes.push(type);\n\t\t\t\t}\n\t\t\t\tvar cached = { extend: extend, override: override, init: init };\n\t\t\t\ttypes.forEach(function (typeKey) {\n\t\t\t\t\tvar entryList = _this.mixins.get(typeKey);\n\t\t\t\t\tif (entryList) {\n\t\t\t\t\t\tentryList.push(cached);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_this.mixins.add(typeKey, [cached]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to generate a type definition.\n\t   * @param {String} typeKey The type.\n\t   * @returns {{create: Function, def: Object}} Returns an object with a definition of the type and a create factory.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"generate\",\n\t\t\tvalue: function generate(typeKey) {\n\t\t\t\tvar entry = this.types.get(typeKey);\n\t\t\t\tif (entry) {\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t\tif (!this.def.structs[typeKey]) {\n\t\t\t\t\tthrow new Error(typeKey + \" not found\");\n\t\t\t\t}\n\t\t\t\tvar type = this.generateApi(typeKey, this.def.structs[typeKey]);\n\t\t\t\tthis.types.add(typeKey, type);\n\t\t\t\treturn type;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to generate an API definition for a given type.\n\t   * @param {String} typeKey The type to generate.\n\t   * @param {Object} def The API definition.\n\t   * @returns {{create: (function(session:Object, handle:Number, id:String, delta:Boolean, customKey:String)), def: Object}} Returns the API definition.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"generateApi\",\n\t\t\tvalue: function generateApi(typeKey, def) {\n\t\t\t\tvar typeDef = Object.create({});\n\t\n\t\t\t\tthis.generateDefaultApi(typeDef, def); //Generate default\n\t\t\t\tthis.mixinType(typeKey, typeDef); //Mixin default type\n\t\n\t\t\t\tvar create = function create(session, handle, id, delta, customKey) {\n\t\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\t\tvar api = Object.create(typeDef);\n\t\n\t\t\t\t\t_eventEmitter2.default.mixin(api); // Always mixin event-emitter per instance\n\t\n\t\t\t\t\tObject.defineProperties(api, {\n\t\t\t\t\t\t\"session\": {\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tvalue: session\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"handle\": {\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tvalue: handle\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"id\": {\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tvalue: id\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"delta\": {\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tvalue: delta\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\tvar mixinList = this.mixins.get(typeKey) || [];\n\t\t\t\t\tif (customKey !== typeKey) {\n\t\t\t\t\t\tthis.mixinType(customKey, api); // Mixin custom types\n\t\t\t\t\t\tmixinList = mixinList.concat(this.mixins.get(customKey) || []);\n\t\t\t\t\t}\n\t\t\t\t\tmixinList.forEach(function (mixin) {\n\t\t\t\t\t\tif (typeof mixin.init === \"function\") {\n\t\t\t\t\t\t\tmixin.init({ Promise: _this2.Promise, api: api });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\treturn api;\n\t\t\t\t}.bind(this);\n\t\n\t\t\t\treturn {\n\t\t\t\t\tcreate: create,\n\t\t\t\t\tdef: typeDef\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to generate the methods with the right handlers to the object API that is being generated.\n\t   * @param {Object} typeDef The object API that is currently being generated.\n\t   * @param {Object} def The API definition.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"generateDefaultApi\",\n\t\t\tvalue: function generateDefaultApi(typeDef, def) {\n\t\t\t\tObject.keys(def).forEach(function (key) {\n\t\t\t\t\tvar fnName = key.substring(0, 1).toLowerCase() + key.substring(1);\n\t\t\t\t\tvar outKey = def[key].Out && def[key].Out.length === 1 ? def[key].Out[0].Name : -1;\n\t\n\t\t\t\t\tvar allowDelta = IGNORE_DELTA_METHODS.indexOf(key) === -1 && outKey !== -1 && outKey !== SUCCESS_KEY;\n\t\n\t\t\t\t\tvar fn = function fn() {\n\t\t\t\t\t\tfor (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\t\t\tparams[_key] = arguments[_key];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this.session.send({\n\t\t\t\t\t\t\tmethod: key,\n\t\t\t\t\t\t\thandle: this.handle,\n\t\t\t\t\t\t\tparams: params,\n\t\t\t\t\t\t\tdelta: this.delta && allowDelta\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\thandle: this.handle,\n\t\t\t\t\t\t\tmethod: key,\n\t\t\t\t\t\t\toutKey: outKey\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\n\t\t\t\t\tObject.defineProperty(typeDef, fnName, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: fn\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to add mixin methods to a specified API.\n\t   * @param {String} typeKey Used to specify which mixin should be woven in.\n\t   * @param {Object} api The object that will be woven.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"mixinType\",\n\t\t\tvalue: function mixinType(typeKey, api) {\n\t\t\t\tvar mixinList = this.mixins.get(typeKey);\n\t\t\t\tif (mixinList) {\n\t\t\t\t\tmixinList.forEach(function (_ref2) {\n\t\t\t\t\t\tvar _ref2$extend = _ref2.extend;\n\t\t\t\t\t\tvar extend = _ref2$extend === undefined ? {} : _ref2$extend;\n\t\t\t\t\t\tvar _ref2$override = _ref2.override;\n\t\t\t\t\t\tvar override = _ref2$override === undefined ? {} : _ref2$override;\n\t\n\t\t\t\t\t\tObject.keys(override).forEach(function (key) {\n\t\t\t\t\t\t\tif (typeof api[key] === \"function\" && typeof override[key] === \"function\") {\n\t\t\t\t\t\t\t\t(function () {\n\t\t\t\t\t\t\t\t\tvar baseFn = api[key];\n\t\t\t\t\t\t\t\t\tapi[key] = function () {\n\t\t\t\t\t\t\t\t\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\t\t\t\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\treturn override[key].apply(this, [baseFn.bind(this)].concat(args));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t})();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Error(\"No function to override. Type: \" + typeKey + \" function: \" + key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tObject.keys(extend).forEach(function (key) {\n\t\t\t\t\t\t\t// handle overrides\n\t\t\t\t\t\t\tif (typeof api[key] === \"function\" && typeof extend[key] === \"function\") {\n\t\t\t\t\t\t\t\tthrow new Error(\"Extend is not allowed for this mixin. Type: \" + typeKey + \" function: \" + key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tapi[key] = extend[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Schema;\n\t}();\n\t\n\texports.default = Schema;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _eventEmitter = __webpack_require__(1);\n\t\n\tvar _eventEmitter2 = _interopRequireDefault(_eventEmitter);\n\t\n\tvar _apiCache = __webpack_require__(6);\n\t\n\tvar _apiCache2 = _interopRequireDefault(_apiCache);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar RETURN_KEY = \"qReturn\";\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t/**\n\t * Session - Handles a session against an endpoint\n\t */\n\t\n\tvar Session = function () {\n\t\n\t\t/**\n\t  * Constructor\n\t  * @param {Object} rpc - The RPC instance used by the session.\n\t  * @param {Boolean} delta=true - Flag to determine delta handling.\n\t  * @param {Object} definition - The definition instance used by the session.\n\t  * @param {Object} JSONPatch - JSON patch object.\n\t  * @param {Function} Promise - The promise constructor.\n\t  */\n\t\n\t\tfunction Session(rpc, delta, definition, JSONPatch, Promise) {\n\t\t\tvar _this = this;\n\t\n\t\t\tvar notifications = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];\n\t\n\t\t\t_classCallCheck(this, Session);\n\t\n\t\t\t_eventEmitter2.default.mixin(this);\n\t\t\tthis.rpc = rpc;\n\t\t\tthis.delta = delta;\n\t\t\tthis.definition = definition;\n\t\t\tthis.JSONPatch = JSONPatch;\n\t\t\tthis.Promise = Promise;\n\t\t\tthis.apis = new _apiCache2.default();\n\t\t\tthis.responseInterceptors = [{\n\t\t\t\tonFulfilled: this.processErrorInterceptor\n\t\t\t}, {\n\t\t\t\tonFulfilled: this.processDeltaInterceptor\n\t\t\t}, {\n\t\t\t\tonFulfilled: this.processResultInterceptor\n\t\t\t}, {\n\t\t\t\tonFulfilled: this.processOutInterceptor\n\t\t\t}, {\n\t\t\t\tonFulfilled: this.processObjectApiInterceptor\n\t\t\t}];\n\t\n\t\t\trpc.on(\"error-socket\", function (err) {\n\t\t\t\treturn _this.emit(\"error-socket\", err);\n\t\t\t});\n\t\t\trpc.on(\"close\", function (evt) {\n\t\t\t\treturn _this.emit(\"close\", evt);\n\t\t\t});\n\t\t\trpc.on(\"notification\", function (response) {\n\t\t\t\t_this.emit(\"notification:*\", response.method, response.params);\n\t\t\t\t_this.emit(\"notification:\" + response.method, response.params);\n\t\t\t});\n\t\n\t\t\trpc.on(\"message\", function (response) {\n\t\n\t\t\t\tif (response.change) {\n\t\t\t\t\tresponse.change.forEach(function (handle) {\n\t\t\t\t\t\treturn _this.emit(\"handle-changed\", handle);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tif (response.close) {\n\t\t\t\t\tresponse.close.forEach(function (handle) {\n\t\t\t\t\t\treturn _this.emit(\"handle-closed\", handle);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tif (response.suspend) {\n\t\t\t\t\t_this.rpc.send({\n\t\t\t\t\t\tmethod: \"Resume\",\n\t\t\t\t\t\tparams: [],\n\t\t\t\t\t\thandle: response.suspend[0]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.on(\"handle-changed\", function (handle) {\n\t\t\t\tvar api = _this.apis.getApi(handle);\n\t\t\t\tif (api) {\n\t\t\t\t\tapi.emit(\"invalidated\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.on(\"handle-closed\", function (handle) {\n\t\t\t\tvar api = _this.apis.getApi(handle);\n\t\t\t\tif (api) {\n\t\t\t\t\tapi.emit(\"closed\");\n\t\t\t\t\t_this.apis.remove(handle);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.on(\"close\", function () {\n\t\t\t\t_this.removeAllListeners();\n\t\t\t\t_this.apis.getApis().forEach(function (entry) {\n\t\t\t\t\tentry.api.emit(\"closed\");\n\t\t\t\t\tentry.api.removeAllListeners();\n\t\t\t\t});\n\t\t\t\t_this.apis.clear();\n\t\t\t});\n\t\n\t\t\tObject.keys(notifications).forEach(function (key) {\n\t\t\t\treturn _this.on(key, notifications[key]);\n\t\t\t});\n\t\t\tthis.emit(\"session-created\", this);\n\t\t}\n\t\n\t\t/**\n\t  * @description Function used to connect to the endpoint.\n\t  * @returns {Object} Returns a promise instance.\n\t  */\n\t\n\t\n\t\t_createClass(Session, [{\n\t\t\tkey: \"connect\",\n\t\t\tvalue: function connect() {\n\t\t\t\treturn this.rpc.open();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to send data to the endpoint.\n\t   * @param {Object} data - The data to be sent.\n\t   * @param {Object} meta - The meta info about the request.\n\t   * @returns {Object} Returns a promise instance.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"send\",\n\t\t\tvalue: function send(data, meta) {\n\t\t\t\tvar promise = this.intercept(this.rpc.send(data), this.responseInterceptors, meta);\n\t\t\t\tSession.addToPromiseChain(promise, \"requestId\", data.id);\n\t\t\t\treturn promise;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to close the endpoint.\n\t   * @returns {Object} Returns a promise instance.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"close\",\n\t\t\tvalue: function close() {\n\t\t\t\treturn this.rpc.close();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get an API for a backend object.\n\t   * @param {Object} args - Arguments used to create object API.\n\t   * @param {Number} args.handle - Handle of the backend object.\n\t   * @param {String} args.id - ID of the backend object.\n\t   * @param {String} args.type - QIX type of the backend object. Can for example be \"Doc\" or \"GenericVariable\".\n\t   * @param {String} args.customType - Custom type of the backend object, if defined in qInfo.\n\t   * @param {Boolean} [args.delta=true] - Flag indicating if delta should be used or not.\n\t   * @returns {*} Returns the generated and possibly augmented API.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getObjectApi\",\n\t\t\tvalue: function getObjectApi(args) {\n\t\t\t\tvar handle = args.handle;\n\t\t\t\tvar id = args.id;\n\t\t\t\tvar type = args.type;\n\t\t\t\tvar customType = args.customType;\n\t\t\t\tvar _args$delta = args.delta;\n\t\t\t\tvar delta = _args$delta === undefined ? true : _args$delta;\n\t\n\t\t\t\tvar api = this.apis.getApi(handle);\n\t\t\t\tif (api) {\n\t\t\t\t\treturn api;\n\t\t\t\t}\n\t\t\t\tapi = this.definition.generate(type).create(this, handle, id, delta, customType);\n\t\t\t\tthis.apis.add(handle, api);\n\t\t\t\treturn api;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to determine if it is a primitive patch.\n\t   * @param  {Array}  patches Patches from engine.\n\t   * @return {Boolean} Returns true if it is a primitive patch.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"isPrimitivePatch\",\n\t\t\tvalue: function isPrimitivePatch(patches) {\n\t\t\t\t//It's only `add` and `replace` that has a\n\t\t\t\t//value property according to the jsonpatch spec\n\t\t\t\treturn patches.length === 1 && [\"add\", \"replace\"].indexOf(patches[0].op) !== -1 && _typeof(patches[0].value) !== \"object\" && patches[0].path === \"/\" && !Array.isArray(patches[0].value);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to get a patchee.\n\t   * @param {Number} handle - The handle.\n\t   * @param {Array} patches - The patches.\n\t   * @param {String} cacheId - The cacheId.\n\t   * @returns {Object} Returns the patchee.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"getPatchee\",\n\t\t\tvalue: function getPatchee(handle, patches, cacheId) {\n\t\t\t\t// handle primitive types, e.g. string, int, bool\n\t\t\t\tif (this.isPrimitivePatch(patches)) {\n\t\t\t\t\tvar value = patches[0].value;\n\t\t\t\t\tthis.apis.setPatchee(handle, cacheId, value);\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\n\t\t\t\tvar patchee = this.apis.getPatchee(handle, cacheId);\n\t\t\t\tvar setPatchee = !patchee;\n\t\t\t\tpatchee = patchee || (patches.length && Array.isArray(patches[0].value) ? [] : {});\n\t\n\t\t\t\tthis.applyPatch(patchee, patches);\n\t\t\t\tif (setPatchee) {\n\t\t\t\t\tthis.apis.setPatchee(handle, cacheId, patchee);\n\t\t\t\t}\n\t\t\t\treturn patchee;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to apply a patch.\n\t   * @param {Object} patchee - The object to patch.\n\t   * @param {Array} patches - The list of patches to apply.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"applyPatch\",\n\t\t\tvalue: function applyPatch(patchee, patches) {\n\t\t\t\tthis.JSONPatch.apply(patchee, patches);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to intercept a request and apply interceptors.\n\t   * @param {Object} promise - A Promise instance that holds the request to intercept.\n\t   * @param {Array<Object>} interceptors - Array of objects with onFulfilled function and onReject function\n\t   * that will be applied to a request.\n\t   * @returns {Promise} Returns a promise.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"intercept\",\n\t\t\tvalue: function intercept(promise, interceptors, meta) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\treturn interceptors.reduce(function (interception, interceptor) {\n\t\t\t\t\treturn interception.then(interceptor.onFulfilled.bind(_this2, meta), interceptor.onRejected);\n\t\t\t\t}, promise);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Process error interceptor.\n\t   * @param {Object} meta - The meta info about the request.\n\t   * @param response - The response.\n\t   * @returns {Object} - Returns the defined error for an error, else the response.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"processErrorInterceptor\",\n\t\t\tvalue: function processErrorInterceptor(_ref, response) {\n\t\t\t\t_objectDestructuringEmpty(_ref);\n\t\n\t\t\t\tif (typeof response.error !== \"undefined\") {\n\t\t\t\t\tthis.emit(\"error-qix\", response.error);\n\t\t\t\t\treturn this.Promise.reject(response.error);\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Process delta interceptor.\n\t   * @param {Object} meta - The meta info about the request.\n\t   * @param response - The response.\n\t   * @returns {Object} - Returns the patched response\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"processDeltaInterceptor\",\n\t\t\tvalue: function processDeltaInterceptor(meta, response) {\n\t\t\t\tvar result = response.result;\n\t\t\t\tif (response.delta) {\n\t\t\t\t\t// when delta is on the response data is expected to be an array of patches\n\t\t\t\t\tvar keys = Object.keys(result);\n\t\t\t\t\tfor (var i = 0, cnt = keys.length; i < cnt; ++i) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\tvar patches = result[key];\n\t\t\t\t\t\tif (!Array.isArray(patches)) {\n\t\t\t\t\t\t\treturn this.Promise.reject(\"Unexpected rpc response, expected array of patches\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult[key] = this.getPatchee(meta.handle, patches, meta.method + \"-\" + key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Process result interceptor.\n\t   * @param {Object} meta - The meta info about the request.\n\t   * @param response - The response.\n\t   * @returns {Object} - Returns the result property on the response\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"processResultInterceptor\",\n\t\t\tvalue: function processResultInterceptor(meta, response) {\n\t\t\t\treturn response.result;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Process out interceptor.\n\t   * @param {Object} meta - The meta info about the request.\n\t   * @param response - The result.\n\t   * @returns {Object} - Returns the out property on result\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"processOutInterceptor\",\n\t\t\tvalue: function processOutInterceptor(meta, result) {\n\t\t\t\tif (hasOwnProperty.call(result, RETURN_KEY)) {\n\t\t\t\t\treturn result[RETURN_KEY];\n\t\t\t\t} else if (meta.outKey !== -1) {\n\t\t\t\t\treturn result[meta.outKey];\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to process the object API interceptor.\n\t   * @param response - The response.\n\t   * @returns {Object} - Returns an object API or the response.\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: \"processObjectApiInterceptor\",\n\t\t\tvalue: function processObjectApiInterceptor(_ref2, response) {\n\t\t\t\t_objectDestructuringEmpty(_ref2);\n\t\n\t\t\t\tif (response.qHandle && response.qType) {\n\t\t\t\t\tvar args = { handle: response.qHandle, type: response.qType, id: response.qGenericId, customType: response.qGenericType, delta: this.delta };\n\t\t\t\t\treturn this.getObjectApi(args);\n\t\t\t\t} else if (response.qHandle === null && response.qType === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @description Function used to add info on the promise chain.\n\t   * @private\n\t   * @param {Promise} promise The promise to add info on.\n\t   * @param {String} name    The property to add info on.\n\t   * @param {Any} value   The info to add.\n\t   */\n\t\n\t\t}], [{\n\t\t\tkey: \"addToPromiseChain\",\n\t\t\tvalue: function addToPromiseChain(promise, name, value) {\n\t\t\t\tpromise[name] = value;\n\t\t\t\tvar then = promise.then;\n\t\t\t\tpromise.then = function () {\n\t\t\t\t\tfor (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\t\tparams[_key] = arguments[_key];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar chain = then.apply(this, params);\n\t\t\t\t\tSession.addToPromiseChain(chain, name, value);\n\t\t\t\t\treturn chain;\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Session;\n\t}();\n\t\n\texports.default = Session;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Utility functions\n\t */\n\t\n\tvar util = {};\n\t\n\tutil.isObject = function isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tutil.isNumber = function isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tutil.isUndefined = function isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\t\n\tutil.isFunction = function isFunction(arg){\n\t  return typeof arg === 'function';\n\t}\n\t\n\t\n\t/**\n\t * EventEmitter class\n\t */\n\t\n\tfunction EventEmitter() {\n\t  EventEmitter.init.call(this);\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\tEventEmitter.init = function() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t};\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!util.isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error' && !this._events.error) {\n\t    er = arguments[1];\n\t    if (er instanceof Error) {\n\t      throw er; // Unhandled 'error' event\n\t    } else {\n\t      throw Error('Uncaught, unspecified \"error\" event.');\n\t    }\n\t    return false;\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (util.isUndefined(handler))\n\t    return false;\n\t\n\t  if (util.isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (util.isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!util.isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              util.isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (util.isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!util.isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t\n\t      if (util.isFunction(console.error)) {\n\t        console.error('(node) warning: possible EventEmitter memory ' +\n\t                      'leak detected. %d listeners added. ' +\n\t                      'Use emitter.setMaxListeners() to increase limit.',\n\t                      this._events[type].length);\n\t      }\n\t      if (util.isFunction(console.trace))\n\t        console.trace();\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!util.isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!util.isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (util.isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (util.isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (util.isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (Array.isArray(listeners)) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (util.isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (util.isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** enigma.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cbfdf76cef24c08d43ae\n **/","/**\n * Key value cache\n */\nexport default class KeyValueCache {\n\tconstructor() {\n\t\tthis.entries = {};\n\t}\n\n\t/**\n\t * @description Function used to add an entry.\n\t * @param {String} key The key representing an entry.\n\t * @param {*} entry The entry to be added.\n\t */\n\tadd( key, entry ) {\n\t\tkey += \"\";\n\t\tif ( typeof this.entries[key] !== \"undefined\" ) {\n\t\t\tthrow new Error( \"Entry already defined with key \" + key );\n\t\t}\n\t\tthis.entries[key] = entry;\n\t}\n\n\t/**\n\t * @description Function used to set an entry.\n\t * @param {String} key The key representing an entry.\n\t * @param {*} entry The entry.\n\t */\n\tset( key, entry ) {\n\t\tkey += \"\";\n\t\tthis.entries[key] = entry;\n\t}\n\n\t/**\n\t * @description Function used to remove an entry.\n\t * @param {String} key The key representing an entry.\n\t */\n\tremove( key ) {\n\t\tdelete this.entries[key];\n\t}\n\n\t/**\n\t * @description Function used to get an entry.\n\t * @param {String} key The key representing an entry.\n\t * @returns {*} The entry for the key.\n\t */\n\tget( key ) {\n\t\treturn this.entries[key];\n\t}\n\n\t/**\n\t* @description Function used to get a list of all entries.\n\t* @returns {Array} Returns the list of entries including its `key` and `value` properties.\n\t*/\n\tgetAll() {\n\t\treturn Object.keys( this.entries ).map( key => {\n\t\t\treturn {\n\t\t\t\tkey,\n\t\t\t\tvalue: this.entries[key]\n\t\t\t};\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to get a key for an entry.\n\t * @param {*} entry The entry to locate the key for.\n\t * @returns {String} The key representing an entry.\n\t */\n\tgetKey( entry ) {\n\t\treturn Object.keys( this.entries ).filter( key => {\n\t\t\treturn this.entries[key] === entry;\n\t\t} )[0];\n\t}\n\n\t/**\n\t * @description Function used to clear the cache of all entries.\n\t */\n\tclear() {\n\t\tthis.entries = {};\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cache.js\n **/","import EventEmitter from \"node-event-emitter\";\n\n/**\n * @description Event emitter mixin.\n */\nexport default {\n\n\t/**\n\t * @description Function used to add event handling to objects passed in.\n\t * @param {Object} obj Object instance that will get event handling.\n\t */\n\tmixin( obj ) {\n\t\tObject.keys( EventEmitter.prototype ).forEach( key => {\n\t\t\tobj[key] = EventEmitter.prototype[key];\n\t\t} );\n\t\tEventEmitter.init( obj );\n\t}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/event-emitter.js\n **/","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extend/index.js\n ** module id = 2\n ** module chunks = 0\n **/","import KeyValueCache from \"./cache\";\nimport extend from \"extend\";\n\n/* istanbul ignore next */\nlet assign = Object.assign || extend; //N.B Don't use deep in extend\n\n\n/**\n * @description Entry point for communication definitions. You can add pre-defined service definitions that allows you to connect\n * and communicate with API endpoints.\n */\nexport default class Communication {\n\t/**\n\t * @description Creates a Communication object.\n\t */\n\tconstructor() {\n\t\tthis.services = new KeyValueCache();\n\t}\n\n\t/**\n\t * @description Function used to register a communication service definition with a given key.\n\t * @param {String} key Key to associate the defined service.\n\t * @param {Function} fn Function that sets up and connects you to an endpoint.\n\t */\n\tregisterService( key, fn ) {\n\t\tthis.services.add( key, fn );\n\t}\n\n\t/**\n\t * @description Function used to get the API for a service endpoint.\n\t * @param {String} key Key defining which communication definition to retrieve.\n\t * @param {...Object} configs Object literal containing connect parameters for the requested endpoint. Look in each\n\t * service definition for more info.\n\t * @returns {Promise<Object>} Returns a promise containing an instance for the requested API if resolved, else an error is thrown.\n\t */\n\tgetService( key, ...configs ) {\n\t\tlet config = assign( {}, ...configs );\n\t\tlet fn = this.services.get( key );\n\t\treturn fn( config );\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/communication.js\n **/","import Session from \"./session\";\nimport Schema from \"./schema\";\nimport RPC from \"../../rpc\";\nimport KeyValueCache from \"../../cache\";\nimport Patch from \"@qlik/json-patch\";\n\n/**\n * Qix.\n */\nexport default class Qix {\n\n\tconstructor() {\n\t\tthis.sessions = new KeyValueCache();\n\t}\n\t/**\n\t * @description Function used to create a session.\n\t * @param {Object} rpc The RPC instance used by the session.\n\t * @param {Boolean} delta=true Flag to determine delta handling.\n\t * @param {Object} definition The Definition used by the session.\n\t * @param {Object} JSONPatch JSON patch object.\n\t * @param {Function} Promise The promise constructor.\n\t * @returns {Object} Returns an instance of Session.\n\t */\n\tcreateSession( rpc, delta, schema, JSONPatch, Promise, notifications ) {\n\t\treturn new Session( rpc, delta, schema, JSONPatch, Promise, notifications );\n\t}\n\n\t/**\n\t * @description Function used to create an RPC.\n\t * @param {Function} Promise The promise constructor.\n\t * @param {String} url The URL used to connect to an endpoint.\n\t * @param {Function} createSocket The function callback to create a WebSocket.\n\t * @param {Object} sessionConfig - The object to configure the session.\n\t * @returns {Object} Returns an instance of RPC.\n\t */\n\tcreateRPC( Promise, url, createSocket, sessionConfig ) {\n\t\treturn new RPC( Promise, url, createSocket, sessionConfig );\n\t}\n\n\t/**\n\t * @description Function used to build an URL.\n\t * @param {Object} sessionConfig Configuration options for setting up the URL.\n\t * @param {Boolean} [sessionConfig.unsecure=false] Set to true if a unsecure WebSocket should be used.\n\t * @param {String} [sessionConfig.host] The hostname, for example \"localhost\" or \"foo.bar.com\". If omitted, localhost will used.\n\t * @param {String|Number} [sessionConfig.port] The port.\n\t * @param {String} [sessionConfig.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t * @param {String} [sessionConfig.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t * @param {String} [sessionConfig.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t * @param {String} [sessionConfig.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t * @param {String} [sessionConfig.reloadURI] The reloadURI.\n\t * @param {String} [appId] The optional app id.\n\t * @returns {String} Returns the URL.\n\t */\n\tbuildUrl( sessionConfig, appId ) {\n\t\tlet { unsecure, host, port, prefix, subpath, route, identity, reloadURI } = sessionConfig;\n\t\tlet url = \"\";\n\n\t\turl += unsecure ? \"ws\" : \"wss\";\n\t\turl += \"://\";\n\t\turl += host || \"localhost\";\n\n\t\tif( port ) {\n\t\t\turl += \":\" + port;\n\t\t}\n\n\t\turl += prefix || \"/\";\n\n\t\tif( subpath ) {\n\t\t\turl += subpath + \"/\";\n\t\t}\n\n\t\tif( route ) {\n\t\t\turl += route;\n\t\t} else if ( appId && appId !== \"\" ) {\n\t\t\turl += \"app/\" + encodeURIComponent( appId );\n\t\t}\n\n\t\tif ( identity ) {\n\t\t\turl += \"/identity/\" + encodeURIComponent( identity );\n\t\t}\n\n\t\turl += \"?reloadUri=\" + ( reloadURI ? encodeURIComponent( reloadURI ) : \"\" );\n\n\t\treturn url;\n\t}\n\n\t/**\n\t * @description Function used to get a session.\n\t * @param {Object} config The object to configure the session.\n\t * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t * @param {Object} config.schema - The Schema definition used by the session.\n\t * @param {Object} config.session The session configuration.\n\t * @param {Function} config.Promise The promise constructor.\n\t * @returns {Object} Returns a session instance.\n\t */\n\tgetSession( config ) {\n\t\tconst url = this.buildUrl( config.session, config.appId );\n\t\tconst { disableCache } = config.session;\n\n\t\tlet session = !disableCache && this.sessions.get( url );\n\t\tif ( !session ) {\n\t\t\tconst rpc = this.createRPC( config.Promise, url, config.createSocket, config.session );\n\t\t\tsession = this.createSession( rpc, config.delta, config.schema, config.JSONPatch, config.Promise, config.notifications );\n\t\t\tif ( !disableCache ) {\n\t\t\t\tthis.sessions.add( url, session );\n\t\t\t\tsession.on( \"close\", () => this.sessions.remove( url ) );\n\t\t\t}\n\t\t}\n\t\treturn session;\n\t}\n\n\t/**\n\t * @description Function used to get the global API.\n\t * @param {Object} session The session to get the global on.\n\t * @param {Object} config The configuration object for how to connect and retrieve end QIX APIs.\n\t * @param {Function} config.Promise The promise constructor.\n\t * @param {Object} config.schema - The JSON object describing the api.\n\t * @param {String} [config.appId] The app id. If omitted, only the global object is returned. Otherwise both global and app object are returned.\n\t * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t * @param {Object} [config.mixins=[]] An array of mixins.\n\t * @param {Object} [config.session] The session configuration.\n\t * @param {Boolean} [config.session.unsecure=false] Set to true if an unsecure WebSocket should be used.\n\t * @param {String} [config.session.host] Host address.\n\t * @param {Number} [config.session.port] Port to connect to.\n\t * @param {String} [config.session.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t * @param {String} [config.session.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t * @param {String} [config.session.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t * @param {String} [config.session.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t * @param {String} [config.session.reloadURI] The reloadURI.\n\t * @param {String} [config.session.disableCache=false] Set to true if you want a new Session.\n\t * @returns {Promise<Object>} Returns a promise of an instance for the global API.\n\t */\n\tgetGlobal( session, config ) {\n\t\treturn session.connect().then( () => {\n\t\t\tlet args = { handle: -1, id: \"Global\", type: \"Global\", customType: \"Global\", delta: config.delta };\n\t\t\tlet globalApi = session.getObjectApi( args );\n\t\t\tglobalApi.openApp = globalApi.openDoc = ( appId, user = \"\", password = \"\", serial = \"\", noData = false ) => {\n\t\t\t\tconfig.session.route = \"\";\n\t\t\t\tconfig.appId = appId;\n\n\t\t\t\tlet appSession = this.getSession( config );\n\n\t\t\t\tif ( !appSession.apiPromise ) {\n\t\t\t\t\tappSession.apiPromise = appSession.connect().then( () => {\n\t\t\t\t\t\treturn appSession.send( {\n\t\t\t\t\t\t\tmethod: \"OpenDoc\",\n\t\t\t\t\t\t\thandle: -1,\n\t\t\t\t\t\t\tparams: [appId, user, password, serial, !!noData],\n\t\t\t\t\t\t\tdelta: false\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tmethod: \"OpenDoc\",\n\t\t\t\t\t\t\thandle: -1,\n\t\t\t\t\t\t\toutKey: -1\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn appSession.apiPromise;\n\t\t\t};\n\t\t\treturn globalApi;\n\t\t} ).catch( err => {\n\t\t\tsession.emit( \"close\", err );\n\t\t\tthrow err;\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to get the global API and optionally the app.\n\t * @param {Object} session The session to get the global on.\n\t * @param {Object} config The object to configure.\n\t * @returns {Promise} Returns a promise of a global API or an object containing the global API and the app API.\n\t */\n\tget( session, config ) {\n\t\treturn this.getGlobal( session, config ).then( g => {\n\t\t\treturn config.appId ?\n\t\t\t\tg.openApp( config.appId, config.user, config.password, config.serial, config.noData ).then( app => { return { global: g, app: app }; } ) :\n\t\t\t\tg;\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to connect to QIX and return the global API and an optional app API.\n\t * @param {Object} config The configuration object for how to connect and retrieve end QIX APIs.\n\t * @param {Function} config.Promise The promise constructor.\n\t * @param {Function} config.WebSocket The WebSocket constructor.\n\t * @param {Object} config.schema - The JSON object describing the api.\n\t * @param {String} [config.appId] The app id. If omitted, only the global object is returned. Otherwise both global and app object are returned.\n\t * @param {Boolean} [config.delta=true] The flag to enable/disable delta handling.\n\t * @param {Object} [config.mixins=[]] An array of mixins.\n\t * @param {Object} [config.session] The session configuration.\n\t * @param {Boolean} [config.session.unsecure=false] Set to true if an unsecure WebSocket should be used.\n\t * @param {String} [config.session.host] Host address.\n\t * @param {Number} [config.session.port] Port to connect to.\n\t * @param {String} [config.session.prefix] The absolute base path to use when connecting. Used for proxy prefixes.\n\t * @param {String} [config.session.subpath] The subpath. Used to connect to dataprepservice in a server environment.\n\t * @param {String} [config.session.route] Parameter in the ws-url used by the Proxy to route to the correct receiver.\n\t * @param {String} [config.session.identity] Identity to use. If omitted, no identity. Used by migration service.\n\t * @param {String} [config.session.reloadURI] The reloadURI.\n\t * @param {String} [config.session.disableCache=false] Set to true if you want a new Session.\n\t * @returns {Promise<Object>} Returns a promise containing an instance for the global API if resolved. If unresolved, an error will be thrown.\n\t */\n\tconnect( config ) {\n\t\tconfig.session = config.session || {};\n\t\tif( !( config.schema instanceof Schema ) ) {\n\t\t\tconfig.schema = new Schema( config.Promise, config.schema );\n\t\t}\n\t\tconfig.mixins = config.mixins || [];\n\t\tconfig.mixins.forEach( mixin => {\n\t\t\tconfig.schema.registerMixin( mixin );\n\t\t} );\n\t\tconfig.JSONPatch = config.JSONPatch || Patch;\n\n\t\tlet session = this.getSession( config );\n\t\treturn this.get( session, config );\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/qix/index.js\n **/","/*global module, define, require*/\n( function ( root, factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\t\t// amd:\n\t\tdefine( [\"extend\"], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\t\t// common.js:\n\t\tmodule.exports = factory( require( \"extend\" ) );\n\t} else {\n\t\t// browser (root = window):\n\t\troot.JSONPatch = factory( root.extend );\n\t}\n}( this, function ( extend ) {\n\textend = extend.bind( null, true );\n\n\tvar JSONPatch = {};\n\tvar isObject = function ( v ) { return v != null && !Array.isArray( v ) && typeof v === \"object\"; };\n\tvar isArray = Array.isArray;\n\tvar isUndef = function ( v ) { return typeof v === \"undefined\"; };\n\tvar isFunction = function ( v ) { return typeof v === \"function\"; };\n\n\t/**\n\t* Generate an exact duplicate (with no references) of a specific value.\n\t*\n\t* @private\n\t* @param {Object} The value to duplicate\n\t* @returns {Object} a unique, duplicated value\n\t*/\n\tfunction generateValue ( val ) {\n\t\tif ( val ) {\n\t\t\tval = extend( {}, { val: val } ).val;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* An additional type checker used to determine if the property is of internal\n\t* use or not a type that can be translated into JSON (like functions).\n\t*\n\t* @private\n\t* @param {Object} obj The object which has the property to check\n\t* @param {String} The property name to check\n\t* @returns {Boolean} Whether the property is deemed special or not\n\t*/\n\tfunction isSpecialProperty( obj, key ) {\n\t\treturn isFunction( obj[key] ) ||\n\t\t\tkey.substring( 0, 2 ) === \"$$\" ||\n\t\t\tkey.substring( 0, 1 ) === \"_\";\n\t}\n\n\t/**\n\t* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n\t* also creates the object structure needed.\n\t*\n\t* @private\n\t* @param {Object} data The root object to traverse through\n\t* @param {String} The JSON-Pointer string to use when traversing\n\t* @returns {Object} The parent object\n\t*/\n\tfunction getParent( data, str ) {\n\t\tvar seperator = \"/\",\n\t\t\tparts = str.substring( 1 ).split( seperator ).slice( 0, -1 ),\n\t\t\tnumPart;\n\n\t\tparts.forEach( function ( part, i ) {\n\t\t\tif ( i === parts.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnumPart = +part;\n\t\t\tdata = data[numPart || part] = isUndef( data[numPart || part] ) ?\n\t\t\t\t!isNaN( numPart ) ?\n\t\t\t\t\t[] :\n\t\t\t\t\t{} :\n\t\t\t\tdata[part];\n\t\t} );\n\n\t\treturn data;\n\t}\n\n\t/**\n\t* Cleans an object of all its properties, unless they're deemed special or\n\t* cannot be removed by configuration.\n\t*\n\t* @private\n\t* @param {Object} obj The object to clean\n\t*/\n\tfunction emptyObject( obj ) {\n\t\tObject.keys( obj ).forEach( function ( key ) {\n\t\t\tvar config = Object.getOwnPropertyDescriptor( obj, key );\n\n\t\t\tif ( config.configurable && !isSpecialProperty( obj, key ) ) {\n\t\t\t\tdelete obj[key];\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t* Compare an object with another, could be object, array, number, string, bool.\n\t*\n\t* @param {Object} a The first object to compare\n\t* @param {Object} a The second object to compare\n\t* @returns {Boolean} Whether the objects are identical\n\t*/\n\tfunction compare( a, b ) {\n\t\tvar isIdentical = true,\n\t\t\ti, l;\n\n\t\tif ( isObject( a ) && isObject( b ) ) {\n\t\t\tif ( Object.keys( a ).length !== Object.keys( b ).length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tObject.keys( a ).forEach( function ( key ) {\n\t\t\t\tif ( !compare( a[key], b[key] ) ) {\n\t\t\t\t\tisIdentical = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn isIdentical;\n\t\t} else if ( isArray( a ) && isArray( b ) ) {\n\t\t\tif ( a.length !== b.length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor ( i = 0, l = a.length; i < l; i++ ) {\n\t\t\t\tif ( !compare( a[i], b[i] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn a === b;\n\t\t}\n\t}\n\n\t/**\n\t* Generates patches by comparing two arrays.\n\t*\n\t* @private\n\t* @param {Array} oldA The old (original) array, which will be patched\n\t* @param {Array} newA The new array, which will be used to compare against\n\t* @returns {Array} An array of patches (if any)\n\t*/\n\tfunction patchArray( original, newA, basePath ) {\n\t\tvar patches = [],\n\t\t\toldA = original.slice(),\n\t\t\ti, l, tmpIdx = -1;\n\n\t\tfunction findIndex( a, id, idx ) {\n\t\t\tif ( a[idx] && isUndef( a[idx].qInfo ) ) {\n\t\t\t\treturn null;\n\t\t\t} else if ( a[idx] && a[idx].qInfo.qId === id ) {\n\t\t\t\t// shortcut if identical\n\t\t\t\treturn idx;\n\t\t\t}\n\t\t\tfor ( var ii = 0, ll = a.length; ii < ll; ii++ ) {\n\t\t\t\tif ( a[ii] && a[ii].qInfo.qId === id ) {\n\t\t\t\t\treturn ii;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ( compare( newA, oldA ) ) {\n\t\t\t// array is unchanged\n\t\t\treturn patches;\n\t\t}\n\n\t\tif ( !isUndef( newA[0] ) && isUndef( newA[0].qInfo ) ) {\n\t\t\t// we cannot create patches without unique identifiers, replace array...\n\t\t\tpatches.push( {\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: basePath,\n\t\t\t\tvalue: newA\n\t\t\t} );\n\t\t\treturn patches;\n\t\t}\n\n\t\tfor ( i = oldA.length - 1; i >= 0; --i ) {\n\t\t\ttmpIdx = findIndex( newA, oldA[i].qInfo && oldA[i].qInfo.qId, i );\n\t\t\tif ( tmpIdx === -1 ) {\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"remove\",\n\t\t\t\t\tpath: basePath + \"/\" + i\n\t\t\t\t} );\n\t\t\t\toldA.splice( i, 1 );\n\t\t\t} else {\n\t\t\t\tpatches = patches.concat( JSONPatch.generate( oldA[i], newA[tmpIdx], basePath + \"/\" + i ) );\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = 0, l = newA.length; i < l; ++i ) {\n\t\t\ttmpIdx = findIndex( oldA, newA[i].qInfo && newA[i].qInfo.qId );\n\t\t\tif ( tmpIdx === -1 ) {\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: basePath + \"/\" + i,\n\t\t\t\t\tvalue: newA[i]\n\t\t\t\t} );\n\t\t\t\toldA.splice( i, 0, newA[i] );\n\t\t\t} else if ( tmpIdx !== i ) {\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"move\",\n\t\t\t\t\tpath: basePath + \"/\" + i,\n\t\t\t\t\tfrom: basePath + \"/\" + tmpIdx\n\t\t\t\t} );\n\t\t\t\toldA.splice( i, 0, oldA.splice( tmpIdx, 1 )[0] );\n\t\t\t}\n\t\t}\n\t\treturn patches;\n\t}\n\n\t/**\n\t* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n\t*\n\t* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n\t*\n\t* Does NOT currently generate patches for arrays (will replace them)\n\t*\n\t* @param {Object} original The object to patch to\n\t* @param {Object} newData The object to patch from\n\t* @param {String} [basePath] The base path to use when generating the paths for the patches (normally not used)\n\t* @returns {Array} An array of patches\n\t*/\n\tJSONPatch.generate = function ( original, newData, basePath ) {\n\t\tbasePath = basePath || \"\";\n\t\tvar patches = [];\n\n\t\tObject.keys( newData ).forEach( function ( key ) {\n\t\t\tvar val = generateValue( newData[key] ),\n\t\t\t\toldVal = original[key],\n\t\t\t\ttmpPath = basePath + \"/\" + key;\n\n\t\t\tif ( compare( val, oldVal ) || isSpecialProperty( newData, key ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( isUndef( oldVal ) ) {\n\t\t\t\t// property does not previously exist\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: tmpPath,\n\t\t\t\t\tvalue: val\n\t\t\t\t} );\n\t\t\t} else if ( isObject( val ) && isObject( oldVal ) ) {\n\t\t\t\t// we need to generate sub-patches for this, since it already exist\n\t\t\t\tpatches = patches.concat( JSONPatch.generate( oldVal, val, tmpPath ) );\n\t\t\t} else if ( isArray( val ) && isArray( oldVal ) ) {\n\t\t\t\tpatches = patches.concat( patchArray( oldVal, val, tmpPath ) );\n\t\t\t} else {\n\t\t\t\t// it's a simple property (bool, string, number)\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: basePath + \"/\" + key,\n\t\t\t\t\tvalue: val\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tObject.keys( original ).forEach( function ( key ) {\n\t\t\tif ( isUndef( newData[key] ) && !isSpecialProperty( original, key ) ) {\n\t\t\t\t// this property does not exist anymore\n\t\t\t\tpatches.push( {\n\t\t\t\t\top: \"remove\",\n\t\t\t\t\tpath: basePath + \"/\" + key\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\treturn patches;\n\t};\n\n\t/**\n\t* Apply a list of patches to an object.\n\t*\n\t* @param {Object} original The object to patch\n\t* @param {Array} patches The list of patches to apply\n\t*/\n\tJSONPatch.apply = function ( original, patches ) {\n\t\tpatches.forEach( function ( patch ) {\n\t\t\tvar parent = getParent( original, patch.path ),\n\t\t\t\tkey = patch.path.split( \"/\" ).splice( -1 )[0],\n\t\t\t\ttarget = key && isNaN( +key ) ? parent[key] : parent[+key] || parent,\n\t\t\t\tfrom = patch.from ? patch.from.split( \"/\" ).splice( -1 )[0] : null;\n\n\t\t\tif ( patch.path === \"/\" ) {\n\t\t\t\tparent = null;\n\t\t\t\ttarget = original;\n\t\t\t}\n\n\t\t\tif ( patch.op === \"add\" || patch.op === \"replace\" ) {\n\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\t// trust indexes from patches, so don't replace the index if it's an add\n\t\t\t\t\tif ( key === \"-\" ) {\n\t\t\t\t\t\tkey = parent.length;\n\t\t\t\t\t}\n\t\t\t\t\tparent.splice( +key, patch.op === \"add\" ? 0 : 1, patch.value );\n\t\t\t\t} else if ( isArray( target ) && isArray( patch.value ) ) {\n\t\t\t\t\tvar newValues = patch.value.slice();\n\t\t\t\t\t// keep array reference if possible...\n\t\t\t\t\ttarget.length = 0;\n\t\t\t\t\ttarget.push.apply( target, newValues );\n\t\t\t\t} else if ( isObject( target ) && isObject( patch.value ) ) {\n\t\t\t\t\t// keep object reference if possible...\n\t\t\t\t\temptyObject( target );\n\t\t\t\t\textend( target, patch.value );\n\t\t\t\t} else if ( !parent ) {\n\t\t\t\t\tthrow new Error( \"Patchee is not an object we can patch\" );\n\t\t\t\t} else {\n\t\t\t\t\t// simple value\n\t\t\t\t\tparent[key] = patch.value;\n\t\t\t\t}\n\t\t\t} else if ( patch.op === \"move\" ) {\n\t\t\t\tvar oldParent = getParent( original, patch.from );\n\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\tparent.splice( +key, 0, oldParent.splice( +from, 1 )[0] );\n\t\t\t\t} else {\n\t\t\t\t\tparent[key] = oldParent[from];\n\t\t\t\t\tdelete oldParent[from];\n\t\t\t\t}\n\t\t\t} else if ( patch.op === \"remove\" ) {\n\t\t\t\tif ( isArray( parent ) ) {\n\t\t\t\t\tparent.splice( +key, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tdelete parent[key];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t};\n\n\t/**\n\t* Deep clone an object.\n\t*\n\t* @param {Object} obj The object to clone\n\t* @returns {Object} A new object identical to the `obj`\n\t*/\n\tJSONPatch.clone = function ( obj ) {\n\t\treturn extend( {}, obj );\n\t};\n\n\t/**\n\t* Creates a JSON-patch.\n\t*\n\t* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n\t* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val` is the \"from JSON-path\" path\n\t* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n\t* @returns {Object} A patch following the JSON-patch specification\n\t*/\n\tJSONPatch.createPatch = function ( op, val, path ) {\n\t\tvar patch = {\n\t\t\top: op.toLowerCase(),\n\t\t\tpath: path\n\t\t};\n\t\tif ( patch.op === \"move\" ) {\n\t\t\tpatch.from = val;\n\t\t} else if ( typeof val !== \"undefined\" ) {\n\t\t\tpatch.value = val;\n\t\t}\n\t\treturn patch;\n\t};\n\n\t/**\n\t* Apply the differences of two objects (keeping references if possible).\n\t* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n\t*\n\t* @param {Object} original The object to update/patch\n\t* @param {Object} newData the object to diff against\n\t*\n\t* @example\n\t* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n\t* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n\t* JSONPatch.updateObject(obj1, obj2);\n\t* // => { foo: [4,5,6], bar: { baz: false } };\n\t*/\n\tJSONPatch.updateObject = function ( original, newData ) {\n\t\tif ( !Object.keys( original ).length ) {\n\t\t\textend( original, newData );\n\t\t\treturn;\n\t\t}\n\t\tJSONPatch.apply( original, JSONPatch.generate( original, newData ) );\n\t};\n\n\treturn JSONPatch;\n} ) );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/@qlik/json-patch/src/index.js\n ** module id = 5\n ** module chunks = 0\n **/","import KeyValueCache from \"./cache\";\n\n/**\n * Api cache.\n */\nexport default class ApiCache extends KeyValueCache {\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Adds an api.\n\t * @param {Number} handle - The handle for the api.\n\t * @param {*} api - The api.\n\t * @returns {{api: *, deltaCache}} The entry.\n\t */\n\tadd( handle, api ) {\n\t\tlet entry = {\n\t\t\tapi: api,\n\t\t\tdeltaCache: new KeyValueCache()\n\t\t};\n\t\tsuper.add( handle.toString(), entry );\n\t\treturn entry;\n\t}\n\n\t/**\n\t * Gets an api.\n\t * @param {Number} handle - The handle for the api.\n\t * @returns {*} The api for the handle.\n\t */\n\tgetApi( handle ) {\n\t\tlet entry = this.get( handle.toString() );\n\t\treturn entry && entry.api;\n\t}\n\n\t/**\n\t* Gets a list of apis.\n\t* @returns {Array} The list of entries with `handle` and `api` properties for each entry.\n\t*/\n\tgetApis() {\n\t\treturn super.getAll().map( entry => {\n\t\t\treturn {\n\t\t\t\thandle: entry.key,\n\t\t\t\tapi: entry.value.api\n\t\t\t};\n\t\t} );\n\t}\n\n\t/**\n\t * Gets a patchee.\n\t * @param {Number} handle - The handle for the api.\n\t * @param {String} method - The method.\n\t * @returns {*} The patchee.\n\t */\n\tgetPatchee( handle, method ) {\n\t\tlet entry = this.get( handle.toString() );\n\t\treturn entry && entry.deltaCache.get( method );\n\t}\n\n\t/**\n\t * Adds a patchee\n\t * @param {Number} handle - The handle for the api.\n\t * @param {String} method - The method.\n\t * @param {Object} patchee - The patchee to add.\n\t */\n\taddPatchee( handle, method, patchee ) {\n\t\tthis.get( handle.toString() ).deltaCache.add( method, patchee );\n\t}\n\n\t/**\n\t * Sets a patchee\n\t * @param {Number} handle - The handle for the api.\n\t * @param {String} method - The method.\n\t * @param {Object} patchee - The patchee to add.\n\t */\n\tsetPatchee( handle, method, patchee ) {\n\t\tthis.get( handle.toString() ).deltaCache.set( method, patchee );\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api-cache.js\n **/","/**\n * @description EnigmaJS Communication module.\n * Add end point definitions to this object to retrieve sessions or HTTP REST communication API objects.\n * The communication module comes with a pre-defined Qlik Sense Qix Engine definition.\n */\nimport Communication from \"./communication\";\nimport Qix from \"./services/qix/index\";\n\nlet communication = new Communication();\nlet qix = new Qix();\ncommunication.registerService( \"qix\", qix.connect.bind( qix ) );\n\nexport default communication;\nmodule.exports = communication;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import Events from \"./event-emitter\";\n\nexport default class RPCResolver {\n\tconstructor( id, resolve, reject ) {\n\t\tEvents.mixin( this );\n\t\tthis.id = id;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t}\n\tresolveWith( data ) {\n\t\tthis.resolve( data );\n\t\tthis.emit( \"resolved\", this.id );\n\t}\n\trejectWith( err ) {\n\t\tthis.reject( err );\n\t\tthis.emit( \"rejected\", this.id );\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/rpc-resolver.js\n **/","import Events from \"./event-emitter\";\nimport RPCResolver from \"./rpc-resolver\";\n\n/**\n * RPC - Handle remote procedure calls\n */\nexport default class RPC {\n\t/**\n\t * @description Constructor\n\t * @param {Function} Promise - The promise constructor.\n\t * @param {String} url - The URL used to connect to an endpoint.\n\t * @param {Function} createSocket The function callback to create a WebSocket.\n\t * @param {Object} sessionConfig - The object to configure the session.\n\t */\n\tconstructor ( Promise, url, createSocket, sessionConfig ) {\n\t\tEvents.mixin( this );\n\t\tthis.Promise = Promise;\n\t\tthis.url = url;\n\t\tthis.createSocket = createSocket;\n\t\tthis.sessionConfig = sessionConfig;\n\t\tthis.resolvers = {};\n\t\tthis.requestId = 0;\n\t\tthis.openPromise = undefined;\n\t}\n\n\t/**\n\t * @description Function used to open a connection to the configured endpoint.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\topen () {\n\t\tif( this.openPromise ) {\n\t\t\treturn this.openPromise;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.socket = this.createSocket( this.url, this.sessionConfig );\n\t\t} catch( err ) {\n\t\t\treturn this.Promise.reject( err );\n\t\t}\n\n\t\tthis.socket.onopen = this.onOpen.bind( this );\n\t\tthis.socket.onclose = this.onClose.bind( this );\n\t\tthis.socket.onerror = this.onError.bind( this );\n\t\tthis.socket.onmessage = this.onMessage.bind( this );\n\t\tthis.openPromise = new this.Promise( ( resolve, reject ) => this.registerResolver( \"open\", resolve, reject ) );\n\t\tthis.closePromise = new this.Promise( ( resolve, reject ) => this.registerResolver( \"close\", resolve, reject ) );\n\t\treturn this.openPromise;\n\t}\n\n\t/**\n\t * @description Function used to resolve the open promise when a connection is successfully established.\n\t */\n\tonOpen () {\n\t\tthis.resolvers.open.resolveWith(\n\t\t\t() => { return this.closePromise; }\n\t\t);\n\t}\n\n\t/**\n\t * @description Function used to resolve the close promise when a connection is closed.\n\t * @param {Object} event - The event describing close.\n\t */\n\tonClose ( event ) {\n\t\tthis.emit( \"close\", event );\n\t\tthis.resolvers.close.resolveWith( event );\n\t\tthis.rejectAllOutstandingResolvers();\n\t}\n\n\t/**\n\t * @description Function used to close a connection.\n\t * @param {Number} [code=1000] - The reason code for closing the connection.\n\t * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\tclose ( code = 1000, reason = \"\" ) {\n\t\tthis.socket.close( code, reason );\n\t\treturn this.closePromise;\n\t}\n\n\t/**\n\t * @description Emits an error event and rejects the open promise if an error is raised on the connection.\n\t * @param {Object} event - The event describing the error.\n\t */\n\tonError( event ) {\n\t\tif( this.resolvers.open ) {\n\t\t\tthis.resolvers.open.rejectWith( event );\n\t\t} else {\n\t\t\t// only emit errors after the initial open promise has been resolved,\n\t\t\t// this makes it possible to catch early websocket errors as well\n\t\t\t// as run-time ones:\n\t\t\tthis.emit( \"error-socket\", event );\n\t\t}\n\t\tthis.rejectAllOutstandingResolvers();\n\t}\n\n\t/**\n\t * @description Function used to parse the onMessage event on the connection and resolve the promise for the request.\n\t * @param {Object} event - The event describing the message.\n\t */\n\tonMessage ( event ) {\n\t\tlet data = JSON.parse( event.data );\n\t\tif ( typeof data.id !== \"undefined\" ) {\n\t\t\tthis.emit( \"message\", data );\n\t\t\tthis.resolvers[data.id].resolveWith( data );\n\t\t} else {\n\t\t\tthis.emit( data.params ? \"notification\" : \"message\", data );\n\t\t}\n\t}\n\n\t/**\n\t * @description Function used to reject all outstanding resolvers.\n\t */\n\trejectAllOutstandingResolvers() {\n\t\tObject.keys( this.resolvers ).forEach( id => {\n\t\t\tif ( id === \"open\" || id === \"close\" ) {\n\t\t\t\treturn; //\"open\" and \"close\" should not be handled here\n\t\t\t}\n\t\t\tconst resolver = this.resolvers[id];\n\t\t\tresolver.rejectWith();\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to unregister a resolver.\n\t * @param {Number|String} id - The ID to unregister the resolver with.\n\t */\n\tunregisterResolver( id ) {\n\t\tconst resolver = this.resolvers[id];\n\t\tresolver.removeAllListeners();\n\t\tdelete this.resolvers[id];\n\t}\n\n\t/**\n\t * @description Function used to register a resolver.\n\t * @param {Number|String} id - The ID to register the resolver with.\n\t * @returns {Function} Returns the promise executor function.\n\t */\n\tregisterResolver ( id, resolve, reject ) {\n\t\tconst resolver = this.resolvers[id] = new RPCResolver( id, resolve, reject );\n\t\tresolver.on( \"resolved\", resolvedId => this.unregisterResolver( resolvedId ) );\n\t\tresolver.on( \"rejected\", rejectedId => this.unregisterResolver( rejectedId ) );\n\t}\n\n\t/**\n\t * @description Function used to send data on the socket.\n\t * @param {Object} data - The data to send.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\tsend ( data ) {\n\t\tif ( !this.socket || this.socket.readyState !== this.socket.OPEN ) {\n\t\t\treturn this.Promise.reject( new Error( \"Not connected\" ) );\n\t\t}\n\t\tdata.jsonrpc = \"2.0\";\n\t\tdata.id = ++this.requestId;\n\t\tthis.socket.send( JSON.stringify( data ) );\n\t\treturn new this.Promise( ( resolve, reject ) => this.registerResolver( data.id, resolve, reject ) );\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/rpc.js\n **/","import KeyValueCache from \"../../cache\";\nimport Events from \"../../event-emitter\";\n\nconst IGNORE_DELTA_METHODS = [\n\t\"GetProperties\",\n\t\"SetProperties\",\n\t\"GetFullPropertyTree\",\n\t\"SetFullPropertyTree\",\n\t\"GetAppProperties\",\n\t\"SetAppProperties\"\n];\n\nconst SUCCESS_KEY = \"qSuccess\";\n\n/**\n * Definitions\n */\nexport default class Schema {\n\n\t/**\n\t * @description Constructor.\n\t * @param {Function} Promise The constructor function for a promise.\n\t * @param {Object} json The JSON object that describes the API.\n\t */\n\tconstructor( Promise, json ) {\n\t\tthis.Promise = Promise;\n\t\tthis.mixins = new KeyValueCache();\n\t\tthis.def = json;\n\t\tthis.types = new KeyValueCache();\n\t}\n\n\t/**\n\t * @description Function used to add a mixin object to the mixin cache. Will be mixed into the API\n\t * of the specified key when generated.\n\t * @param {Object} mixin Mixin object.\n\t * @param {String|Array<String>} mixin.types String or array of strings containing the API-types that will be mixed in.\n\t * @param {Object} [mixin.extend] Object literal containing the methods that will be extended on the specified API.\n\t * @param {Object} [mixin.override] Object literal containing the methods to override existing methods.\n\t * @param {Function} [mixin.init] Init function that, if defined, will run when an API is instantiated. It runs with Promise and API object as parameters.\n\t */\n\tregisterMixin( { types, type, extend, override, init } ) {\n\t\tif ( !Array.isArray( types ) ) {\n\t\t\ttypes = [types];\n\t\t}\n\t\t// to support a single type\n\t\tif ( type ) {\n\t\t\ttypes.push( type );\n\t\t}\n\t\tlet cached = { extend, override, init };\n\t\ttypes.forEach( typeKey => {\n\t\t\tlet entryList = this.mixins.get( typeKey );\n\t\t\tif ( entryList ) {\n\t\t\t\tentryList.push( cached );\n\t\t\t} else {\n\t\t\t\tthis.mixins.add( typeKey, [ cached ] );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to generate a type definition.\n\t * @param {String} typeKey The type.\n\t * @returns {{create: Function, def: Object}} Returns an object with a definition of the type and a create factory.\n\t */\n\tgenerate( typeKey ) {\n\t\tlet entry = this.types.get( typeKey );\n\t\tif ( entry ) {\n\t\t\treturn entry;\n\t\t}\n\t\tif ( !this.def.structs[typeKey] ) {\n\t\t\tthrow new Error( `${typeKey} not found` );\n\t\t}\n\t\tlet type = this.generateApi( typeKey, this.def.structs[typeKey] );\n\t\tthis.types.add( typeKey, type );\n\t\treturn type;\n\t}\n\n\t/**\n\t * @description Function used to generate an API definition for a given type.\n\t * @param {String} typeKey The type to generate.\n\t * @param {Object} def The API definition.\n\t * @returns {{create: (function(session:Object, handle:Number, id:String, delta:Boolean, customKey:String)), def: Object}} Returns the API definition.\n\t */\n\tgenerateApi( typeKey, def ) {\n\t\tlet typeDef = Object.create( {} );\n\n\t\tthis.generateDefaultApi( typeDef, def ); //Generate default\n\t\tthis.mixinType( typeKey, typeDef ); //Mixin default type\n\n\t\tlet create = function create( session, handle, id, delta, customKey ) {\n\t\t\tlet api = Object.create( typeDef );\n\n\t\t\tEvents.mixin( api ); // Always mixin event-emitter per instance\n\n\t\t\tObject.defineProperties( api, {\n\t\t\t\t\"session\": {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: session\n\t\t\t\t},\n\t\t\t\t\"handle\": {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: handle\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: id\n\t\t\t\t},\n\t\t\t\t\"delta\": {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: delta\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tlet mixinList = this.mixins.get( typeKey ) || [];\n\t\t\tif( customKey !== typeKey ) {\n\t\t\t\tthis.mixinType( customKey, api ); // Mixin custom types\n\t\t\t\tmixinList = mixinList.concat( this.mixins.get( customKey ) || [] );\n\t\t\t}\n\t\t\tmixinList.forEach( mixin => {\n\t\t\t\tif ( typeof mixin.init === \"function\" ) {\n\t\t\t\t\tmixin.init( { Promise: this.Promise, api: api } );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn api;\n\n\t\t}.bind( this );\n\n\t\treturn {\n\t\t\tcreate: create,\n\t\t\tdef: typeDef\n\t\t};\n\t}\n\n\t/**\n\t * @description Function used to generate the methods with the right handlers to the object API that is being generated.\n\t * @param {Object} typeDef The object API that is currently being generated.\n\t * @param {Object} def The API definition.\n\t */\n\tgenerateDefaultApi( typeDef, def ) {\n\t\tObject.keys( def ).forEach( key => {\n\t\t\tlet fnName = key.substring( 0, 1 ).toLowerCase() + key.substring( 1 );\n\t\t\tlet outKey = def[key].Out && def[key].Out.length === 1 ? def[key].Out[0].Name : -1;\n\n\t\t\tlet allowDelta = IGNORE_DELTA_METHODS.indexOf( key ) === -1 && outKey !== -1 && outKey !== SUCCESS_KEY;\n\n\t\t\tlet fn = function ( ...params ) {\n\t\t\t\treturn this.session.send( {\n\t\t\t\t\tmethod: key,\n\t\t\t\t\thandle: this.handle,\n\t\t\t\t\tparams: params,\n\t\t\t\t\tdelta: this.delta && allowDelta\n\t\t\t\t}, {\n\t\t\t\t\thandle: this.handle,\n\t\t\t\t\tmethod: key,\n\t\t\t\t\toutKey: outKey\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tObject.defineProperty( typeDef, fnName, {\n\t\t\t\tenumerable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: fn\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * @description Function used to add mixin methods to a specified API.\n\t * @param {String} typeKey Used to specify which mixin should be woven in.\n\t * @param {Object} api The object that will be woven.\n\t */\n\tmixinType( typeKey, api ) {\n\t\tlet mixinList = this.mixins.get( typeKey );\n\t\tif ( mixinList ) {\n\t\t\tmixinList.forEach( ( { extend = {}, override = {} } ) => {\n\t\t\t\tObject.keys( override ).forEach( key => {\n\t\t\t\t\tif ( typeof api[key] === \"function\" && typeof override[key] === \"function\" ) {\n\t\t\t\t\t\tlet baseFn = api[key];\n\t\t\t\t\t\tapi[key] = function( ...args ) {\n\t\t\t\t\t\t\treturn override[key].apply( this, [baseFn.bind( this ), ...args] );\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error( \"No function to override. Type: \" + typeKey + \" function: \" + key );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tObject.keys( extend ).forEach( key => {\n\t\t\t\t\t// handle overrides\n\t\t\t\t\tif ( typeof api[key] === \"function\" && typeof extend[key] === \"function\" ) {\n\t\t\t\t\t\tthrow new Error( \"Extend is not allowed for this mixin. Type: \" + typeKey + \" function: \" + key );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapi[key] = extend[key];\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/qix/schema.js\n **/","import Events from \"../../event-emitter\";\nimport ApiCache from \"../../api-cache\";\n\nconst RETURN_KEY = \"qReturn\";\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Session - Handles a session against an endpoint\n */\nexport default class Session {\n\n\t/**\n\t * Constructor\n\t * @param {Object} rpc - The RPC instance used by the session.\n\t * @param {Boolean} delta=true - Flag to determine delta handling.\n\t * @param {Object} definition - The definition instance used by the session.\n\t * @param {Object} JSONPatch - JSON patch object.\n\t * @param {Function} Promise - The promise constructor.\n\t */\n\tconstructor ( rpc, delta, definition, JSONPatch, Promise, notifications = {} ) {\n\t\tEvents.mixin( this );\n\t\tthis.rpc = rpc;\n\t\tthis.delta = delta;\n\t\tthis.definition = definition;\n\t\tthis.JSONPatch = JSONPatch;\n\t\tthis.Promise = Promise;\n\t\tthis.apis = new ApiCache();\n\t\tthis.responseInterceptors = [{\n\t\t\tonFulfilled: this.processErrorInterceptor\n\t\t}, {\n\t\t\tonFulfilled: this.processDeltaInterceptor\n\t\t}, {\n\t\t\tonFulfilled: this.processResultInterceptor\n\t\t}, {\n\t\t\tonFulfilled: this.processOutInterceptor\n\t\t}, {\n\t\t\tonFulfilled: this.processObjectApiInterceptor\n\t\t}];\n\n\t\trpc.on( \"error-socket\", err => this.emit( \"error-socket\", err ) );\n\t\trpc.on( \"close\", evt => this.emit( \"close\", evt ) );\n\t\trpc.on( \"notification\", response => {\n\t\t\tthis.emit( \"notification:*\", response.method, response.params );\n\t\t\tthis.emit( \"notification:\" + response.method, response.params );\n\t\t} );\n\n\t\trpc.on( \"message\", response => {\n\n\t\t\tif ( response.change ) {\n\t\t\t\tresponse.change.forEach( handle => this.emit( \"handle-changed\", handle ) );\n\t\t\t}\n\n\t\t\tif ( response.close ) {\n\t\t\t\tresponse.close.forEach( handle => this.emit( \"handle-closed\", handle ) );\n\t\t\t}\n\n\t\t\tif ( response.suspend ) {\n\t\t\t\tthis.rpc.send( {\n\t\t\t\t\tmethod: \"Resume\",\n\t\t\t\t\tparams: [],\n\t\t\t\t\thandle: response.suspend[0]\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tthis.on( \"handle-changed\", handle => {\n\t\t\tconst api = this.apis.getApi( handle );\n\t\t\tif ( api ) {\n\t\t\t\tapi.emit( \"invalidated\" );\n\t\t\t}\n\t\t} );\n\n\t\tthis.on( \"handle-closed\", handle => {\n\t\t\tconst api = this.apis.getApi( handle );\n\t\t\tif ( api ) {\n\t\t\t\tapi.emit( \"closed\" );\n\t\t\t\tthis.apis.remove( handle );\n\t\t\t}\n\t\t} );\n\n\t\tthis.on( \"close\", () => {\n\t\t\tthis.removeAllListeners();\n\t\t\tthis.apis.getApis().forEach( entry => {\n\t\t\t\tentry.api.emit( \"closed\" );\n\t\t\t\tentry.api.removeAllListeners();\n\t\t\t} );\n\t\t\tthis.apis.clear();\n\t\t} );\n\n\t\tObject.keys( notifications ).forEach( key => this.on( key, notifications[key] ) );\n\t\tthis.emit( \"session-created\", this );\n\t}\n\n\t/**\n\t * @description Function used to connect to the endpoint.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\tconnect() {\n\t\treturn this.rpc.open();\n\t}\n\n\t/**\n\t * @description Function used to send data to the endpoint.\n\t * @param {Object} data - The data to be sent.\n\t * @param {Object} meta - The meta info about the request.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\tsend( data, meta ) {\n\t\tconst promise = this.intercept( this.rpc.send( data ), this.responseInterceptors, meta );\n\t\tSession.addToPromiseChain( promise, \"requestId\", data.id );\n\t\treturn promise;\n\t}\n\n\t/**\n\t * @description Function used to close the endpoint.\n\t * @returns {Object} Returns a promise instance.\n\t */\n\tclose() {\n\t\treturn this.rpc.close();\n\t}\n\n\t/**\n\t * @description Function used to get an API for a backend object.\n\t * @param {Object} args - Arguments used to create object API.\n\t * @param {Number} args.handle - Handle of the backend object.\n\t * @param {String} args.id - ID of the backend object.\n\t * @param {String} args.type - QIX type of the backend object. Can for example be \"Doc\" or \"GenericVariable\".\n\t * @param {String} args.customType - Custom type of the backend object, if defined in qInfo.\n\t * @param {Boolean} [args.delta=true] - Flag indicating if delta should be used or not.\n\t * @returns {*} Returns the generated and possibly augmented API.\n\t */\n\tgetObjectApi( args ) {\n\t\tlet { handle, id, type, customType, delta = true } = args;\n\t\tlet api = this.apis.getApi( handle );\n\t\tif ( api ) {\n\t\t\treturn api;\n\t\t}\n\t\tapi = this.definition\n\t\t\t.generate( type )\n\t\t\t.create( this, handle, id, delta, customType );\n\t\tthis.apis.add( handle, api );\n\t\treturn api;\n\t}\n\n\t/**\n\t * @description Function used to determine if it is a primitive patch.\n\t * @param  {Array}  patches Patches from engine.\n\t * @return {Boolean} Returns true if it is a primitive patch.\n\t */\n\tisPrimitivePatch( patches ) {\n\t\t//It's only `add` and `replace` that has a\n\t\t//value property according to the jsonpatch spec\n\t\treturn patches.length === 1 &&\n\t\t\t[\"add\", \"replace\"].indexOf( patches[0].op ) !== -1 &&\n\t\t\ttypeof patches[0].value !== \"object\" &&\n\t\t\tpatches[0].path === \"/\" &&\n\t\t\t!Array.isArray( patches[0].value );\n\t}\n\n\t/**\n\t * @description Function used to get a patchee.\n\t * @param {Number} handle - The handle.\n\t * @param {Array} patches - The patches.\n\t * @param {String} cacheId - The cacheId.\n\t * @returns {Object} Returns the patchee.\n\t */\n\tgetPatchee( handle, patches, cacheId ) {\n\t\t// handle primitive types, e.g. string, int, bool\n\t\tif ( this.isPrimitivePatch( patches ) ) {\n\t\t\tconst value = patches[0].value;\n\t\t\tthis.apis.setPatchee( handle, cacheId, value );\n\t\t\treturn value;\n\t\t}\n\n\t\tlet patchee = this.apis.getPatchee( handle, cacheId );\n\t\tconst setPatchee = !patchee;\n\t\tpatchee = patchee || ( patches.length && Array.isArray( patches[0].value ) ? [] : {} );\n\n\t\tthis.applyPatch( patchee, patches );\n\t\tif( setPatchee ) {\n\t\t\tthis.apis.setPatchee( handle, cacheId, patchee );\n\t\t}\n\t\treturn patchee;\n\t}\n\n\t/**\n\t * @description Function used to apply a patch.\n\t * @param {Object} patchee - The object to patch.\n\t * @param {Array} patches - The list of patches to apply.\n\t */\n\tapplyPatch( patchee, patches ) {\n\t\tthis.JSONPatch.apply( patchee, patches );\n\t}\n\n\t/**\n\t * @description Function used to intercept a request and apply interceptors.\n\t * @param {Object} promise - A Promise instance that holds the request to intercept.\n\t * @param {Array<Object>} interceptors - Array of objects with onFulfilled function and onReject function\n\t * that will be applied to a request.\n\t * @returns {Promise} Returns a promise.\n\t */\n\tintercept( promise, interceptors, meta ) {\n\t\treturn interceptors.reduce( ( interception, interceptor ) => {\n\t\t\treturn interception.then( interceptor.onFulfilled.bind( this, meta ), interceptor.onRejected );\n\t\t}, promise );\n\t}\n\n\t/**\n\t * @description Process error interceptor.\n\t * @param {Object} meta - The meta info about the request.\n\t * @param response - The response.\n\t * @returns {Object} - Returns the defined error for an error, else the response.\n\t */\n\tprocessErrorInterceptor( {}, response ) {\n\t\tif ( typeof response.error !== \"undefined\" ) {\n\t\t\tthis.emit( \"error-qix\", response.error );\n\t\t\treturn this.Promise.reject( response.error );\n\t\t}\n\t\treturn response;\n\t}\n\n\t/**\n\t * @description Process delta interceptor.\n\t * @param {Object} meta - The meta info about the request.\n\t * @param response - The response.\n\t * @returns {Object} - Returns the patched response\n\t */\n\tprocessDeltaInterceptor( meta, response ) {\n\t\tconst result = response.result;\n\t\tif ( response.delta ) {\n\t\t\t// when delta is on the response data is expected to be an array of patches\n\t\t\tlet keys = Object.keys( result );\n\t\t\tfor( let i = 0, cnt = keys.length; i < cnt; ++i ) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tconst patches = result[key];\n\t\t\t\tif( !Array.isArray( patches ) ) {\n\t\t\t\t\treturn this.Promise.reject( \"Unexpected rpc response, expected array of patches\" );\n\t\t\t\t}\n\t\t\t\tresult[key] = this.getPatchee( meta.handle, patches, meta.method + \"-\" + key );\n\t\t\t}\n\t\t}\n\t\treturn response;\n\t}\n\n\t/**\n\t * @description Process result interceptor.\n\t * @param {Object} meta - The meta info about the request.\n\t * @param response - The response.\n\t * @returns {Object} - Returns the result property on the response\n\t */\n\tprocessResultInterceptor( meta, response ) {\n\t\treturn response.result;\n\t}\n\n\t/**\n\t * @description Process out interceptor.\n\t * @param {Object} meta - The meta info about the request.\n\t * @param response - The result.\n\t * @returns {Object} - Returns the out property on result\n\t */\n\tprocessOutInterceptor( meta, result ) {\n\t\tif ( hasOwnProperty.call( result, RETURN_KEY ) ) {\n\t\t\treturn result[RETURN_KEY];\n\t\t} else if ( meta.outKey !== -1 ) {\n\t\t\treturn result[meta.outKey];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @description Function used to process the object API interceptor.\n\t * @param response - The response.\n\t * @returns {Object} - Returns an object API or the response.\n\t */\n\tprocessObjectApiInterceptor( {}, response ) {\n\t\tif ( response.qHandle && response.qType ) {\n\t\t\tlet args = { handle: response.qHandle, type: response.qType, id: response.qGenericId, customType: response.qGenericType, delta: this.delta };\n\t\t\treturn this.getObjectApi( args );\n\t\t} else if ( response.qHandle === null && response.qType === null ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn response;\n\t}\n\n\t/**\n\t * @description Function used to add info on the promise chain.\n\t * @private\n\t * @param {Promise} promise The promise to add info on.\n\t * @param {String} name    The property to add info on.\n\t * @param {Any} value   The info to add.\n\t */\n\tstatic addToPromiseChain( promise, name, value ) {\n\t\tpromise[name] = value;\n\t\tconst then = promise.then;\n\t\tpromise.then = function ( ...params ) {\n\t\t\tconst chain = then.apply( this, params );\n\t\t\tSession.addToPromiseChain( chain, name, value );\n\t\t\treturn chain;\n\t\t};\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/qix/session.js\n **/","/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-event-emitter/index.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}